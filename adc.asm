; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29333.0 

include listing.inc

INCLUDELIB OLDNAMES

EXTRN	__imp_malloc:PROC
EXTRN	__security_check_cookie:PROC
PUBLIC	main
PUBLIC	adc_u32
PUBLIC	speck64u96
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN66
	DD	imagerel $LN66+1424
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$adc_u32 DD imagerel $LN19
	DD	imagerel $LN19+85
	DD	imagerel $unwind$adc_u32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adc_u32 DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\speck.h
;	COMDAT speck64u96
_TEXT	SEGMENT
Pt$ = 8
KeyLo$ = 16
KeyHiLo$ = 24
KeyHiHi$ = 32
speck64u96 PROC						; COMDAT

; 11   : 	extern unsigned int _rotl(unsigned int, int);
; 12   : 	extern unsigned int _rotr(unsigned int, int);
; 13   : #define _SPECKXXR(x, y, k) \
; 14   : 	(y = _rotr(x ^ y, 3),  \
; 15   : 		x = _rotl(         \
; 16   : 			(unsigned long long)((x ^ (k)) - y), 8))
; 17   : #define _SPECKXX(Hi, Lo, k)          \
; 18   : 	(Hi = (_rotr(Hi, 8) + Lo) ^ (k), \
; 19   : 		Lo = _rotl(Lo, 3) ^ Hi)
; 20   : 	unsigned int CtHi = Pt >> 32,

	mov	rax, rcx
	shr	rax, 32					; 00000020H

; 21   : 				 CtLo = Pt & 0xffffffffu;
; 22   : 	for(int i = 0; i < 26;)

	xor	r10d, r10d
	npad	6
$LL2@speck64u96:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	eax, 8
	add	eax, ecx
	ror	r8d, 8
	xor	eax, edx
	rol	ecx, 3
	add	r8d, edx
	ror	r9d, 8
	xor	ecx, eax
	rol	edx, 3
	xor	r8d, r10d
	ror	eax, 8
	xor	edx, r8d
	add	eax, ecx
	add	r9d, edx
	rol	ecx, 3
	xor	eax, edx
	inc	r10d
	xor	r9d, r10d
	rol	edx, 3
	xor	edx, r9d
	xor	ecx, eax
	inc	r10d
	cmp	r10d, 26
	jl	SHORT $LL2@speck64u96

; 26   : 			_SPECKXX(KeyHiHi, KeyLo, i++));
; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	shl	rax, 32					; 00000020H
	or	rax, rcx

; 28   : #undef _SPECKXXR
; 29   : #undef _SPECKXX
; 30   : }

	ret	0
speck64u96 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\adc.c
;	COMDAT adc_u32
_TEXT	SEGMENT
n$dead$ = 8
a$ = 16
b$ = 24
ans$ = 32
adc_u32	PROC						; COMDAT

; 6    : 	const unsigned int b[], unsigned int ans[]) {

$LN19:
	mov	QWORD PTR [rsp+8], rbx

; 7    : 	int carry = 0;

	xor	eax, eax
	mov	rbx, rdx
	sub	rbx, r8
	mov	r10, r8
	sub	r9, r8
	lea	r11d, QWORD PTR [rax+100]
	npad	9
$LL8@adc_u32:

; 8    : 	for(int i = 0; i < n; i++) {
; 9    : 		const unsigned int a_i = a[i], b_i = b[i],

	mov	ecx, DWORD PTR [r10]
	mov	edx, DWORD PTR [rbx+r10]
	lea	r10, QWORD PTR [r10+4]

; 10   : 						   res_i = a_i + b_i + carry;

	lea	r8d, DWORD PTR [rcx+rdx]
	add	r8d, eax

; 11   : 		carry = (res_i < a_i) | (res_i < b_i);

	xor	eax, eax
	cmp	r8d, ecx

; 12   : 		ans[i] = res_i;

	mov	DWORD PTR [r9+r10-4], r8d
	setb	al
	xor	ecx, ecx
	cmp	r8d, edx
	setb	cl
	or	eax, ecx
	sub	r11, 1
	jne	SHORT $LL8@adc_u32

; 13   : 	}
; 14   : 	return carry;
; 15   : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
adc_u32	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\adc.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\adc.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\adc.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\adc.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\adc.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\adc.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\adc.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\adc.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\adc.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\adc.c
;	COMDAT main
_TEXT	SEGMENT
main	PROC						; COMDAT

; 16   : int main(void) {

$LN66:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 17   : 	const int Num = 100;
; 18   : 	unsigned int *List = malloc(3 * Num * sizeof List[0]);

	mov	ecx, 1200				; 000004b0H
	call	QWORD PTR __imp_malloc
	mov	rbp, rax
	mov	ebx, 1
	lea	rdi, QWORD PTR [rax+4]
	npad	5
$LL4@main:

; 20   : 		List[i] = (uint32_t)speck64u96(i, 22, 33, i + 99999);

	lea	eax, DWORD PTR [rbx-1]
	mov	edx, 22
	movsxd	rcx, eax
	lea	esi, DWORD PTR [rbx+2]
; File C:\Users\user\Desktop\primitive-root\speck.h

; 20   : 	unsigned int CtHi = Pt >> 32,

	shr	rcx, 32					; 00000020H
; File C:\Users\user\Desktop\primitive-root\adc.c

; 20   : 		List[i] = (uint32_t)speck64u96(i, 22, 33, i + 99999);

	lea	r8d, DWORD PTR [rsi+99996]
; File C:\Users\user\Desktop\primitive-root\speck.h

; 22   : 	for(int i = 0; i < 26;)

	xor	r10d, r10d
	lea	eax, DWORD PTR [rbx-1]
; File C:\Users\user\Desktop\primitive-root\adc.c

; 20   : 		List[i] = (uint32_t)speck64u96(i, 22, 33, i + 99999);

	lea	r9d, QWORD PTR [rdx+11]
	npad	13
$LL7@main:
; File C:\Users\user\Desktop\primitive-root\speck.h

; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	ecx, 8
	add	ecx, eax
	ror	r9d, 8
	xor	ecx, edx
	rol	eax, 3
	add	r9d, edx
	ror	r8d, 8
	xor	eax, ecx
	rol	edx, 3
	xor	r9d, r10d
	ror	ecx, 8
	xor	edx, r9d
	add	ecx, eax
	add	r8d, edx
	rol	eax, 3
	xor	ecx, edx
	inc	r10d
	xor	r8d, r10d
	rol	edx, 3
	xor	edx, r8d
	xor	eax, ecx
	inc	r10d
	cmp	r10d, 26
	jl	SHORT $LL7@main
; File C:\Users\user\Desktop\primitive-root\adc.c

; 22   : 			= (uint32_t)speck64u96(i + 1, 98, 87, i + 3);

	mov	DWORD PTR [rdi-4], eax
	mov	edx, 98					; 00000062H
	movsxd	rax, ebx
	mov	r9d, esi
; File C:\Users\user\Desktop\primitive-root\speck.h

; 20   : 	unsigned int CtHi = Pt >> 32,

	shr	rax, 32					; 00000020H

; 21   : 				 CtLo = Pt & 0xffffffffu;

	mov	r8d, ebx
	mov	ecx, eax

; 22   : 	for(int i = 0; i < 26;)

	xor	r11d, r11d
; File C:\Users\user\Desktop\primitive-root\adc.c

; 22   : 			= (uint32_t)speck64u96(i + 1, 98, 87, i + 3);

	lea	r10d, QWORD PTR [rdx-11]
	npad	14
$LL12@main:
; File C:\Users\user\Desktop\primitive-root\speck.h

; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	ecx, 8
	add	ecx, r8d
	ror	r10d, 8
	xor	ecx, edx
	rol	r8d, 3
	add	r10d, edx
	ror	r9d, 8
	xor	r8d, ecx
	rol	edx, 3
	xor	r10d, r11d
	ror	ecx, 8
	xor	edx, r10d
	add	ecx, r8d
	add	r9d, edx
	rol	r8d, 3
	xor	ecx, edx
	inc	r11d
	xor	r9d, r11d
	rol	edx, 3
	xor	edx, r9d
	xor	r8d, ecx
	inc	r11d
	cmp	r11d, 26
	jl	SHORT $LL12@main
; File C:\Users\user\Desktop\primitive-root\adc.c

; 22   : 			= (uint32_t)speck64u96(i + 1, 98, 87, i + 3);

	mov	ecx, 22
	mov	DWORD PTR [rdi+396], r8d
	lea	r8d, DWORD PTR [rbx+99999]
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	mov	edx, ebx

; 22   : 	for(int i = 0; i < 26;)

	xor	r10d, r10d
; File C:\Users\user\Desktop\primitive-root\adc.c

; 20   : 		List[i] = (uint32_t)speck64u96(i, 22, 33, i + 99999);

	lea	r9d, QWORD PTR [rcx+11]
	npad	10
$LL30@main:
; File C:\Users\user\Desktop\primitive-root\speck.h

; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	eax, 8
	add	eax, edx
	ror	r9d, 8
	xor	eax, ecx
	rol	edx, 3
	add	r9d, ecx
	ror	r8d, 8
	xor	edx, eax
	rol	ecx, 3
	xor	r9d, r10d
	ror	eax, 8
	xor	ecx, r9d
	add	eax, edx
	add	r8d, ecx
	rol	edx, 3
	xor	eax, ecx
	inc	r10d
	xor	r8d, r10d
	rol	ecx, 3
	xor	ecx, r8d
	xor	edx, eax
	inc	r10d
	cmp	r10d, 26
	jl	SHORT $LL30@main
; File C:\Users\user\Desktop\primitive-root\adc.c

; 22   : 			= (uint32_t)speck64u96(i + 1, 98, 87, i + 3);

	mov	DWORD PTR [rdi], edx
	lea	r8d, DWORD PTR [rbx+3]
	lea	edx, DWORD PTR [rbx+1]
	mov	ecx, 98					; 00000062H
	movsxd	rax, edx
; File C:\Users\user\Desktop\primitive-root\speck.h

; 20   : 	unsigned int CtHi = Pt >> 32,

	shr	rax, 32					; 00000020H

; 22   : 	for(int i = 0; i < 26;)

	xor	r10d, r10d
; File C:\Users\user\Desktop\primitive-root\adc.c

; 22   : 			= (uint32_t)speck64u96(i + 1, 98, 87, i + 3);

	lea	r9d, QWORD PTR [rcx-11]
$LL32@main:
; File C:\Users\user\Desktop\primitive-root\speck.h

; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	eax, 8
	add	eax, edx
	ror	r9d, 8
	xor	eax, ecx
	rol	edx, 3
	add	r9d, ecx
	ror	r8d, 8
	xor	edx, eax
	rol	ecx, 3
	xor	r9d, r10d
	ror	eax, 8
	xor	ecx, r9d
	add	eax, edx
	add	r8d, ecx
	rol	edx, 3
	xor	eax, ecx
	inc	r10d
	xor	r8d, r10d
	rol	ecx, 3
	xor	ecx, r8d
	xor	edx, eax
	inc	r10d
	cmp	r10d, 26
	jl	SHORT $LL32@main
; File C:\Users\user\Desktop\primitive-root\adc.c

; 19   : 	for(int i = 0; i < Num; i++) {

	mov	DWORD PTR [rdi+400], edx
	mov	ebx, esi
	add	rdi, 8
	cmp	esi, 100				; 00000064H
	jle	$LL4@main

; 7    : 	int carry = 0;

	xor	r8d, r8d
	lea	r9, QWORD PTR [rbp+800]
	lea	r10d, QWORD PTR [r8+5]
	npad	9
$LL19@main:

; 8    : 	for(int i = 0; i < n; i++) {
; 9    : 		const unsigned int a_i = a[i], b_i = b[i],

	mov	ecx, DWORD PTR [r9-800]
	mov	eax, DWORD PTR [r9-400]

; 10   : 						   res_i = a_i + b_i + carry;

	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d

; 11   : 		carry = (res_i < a_i) | (res_i < b_i);

	xor	r8d, r8d
	cmp	edx, eax

; 12   : 		ans[i] = res_i;

	mov	DWORD PTR [r9], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-796]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-396]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9+4], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-792]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-392]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9+8], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-788]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-388]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9+12], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-784]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-384]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9+16], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-780]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-380]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9+20], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-776]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-376]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	setb	al
	mov	DWORD PTR [r9+24], edx
	or	r8d, eax
	mov	ecx, DWORD PTR [r9-772]
	mov	eax, DWORD PTR [r9-372]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9+28], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-768]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-368]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9+32], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-764]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-364]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9+36], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-760]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-360]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9+40], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-756]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-356]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9+44], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-752]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-352]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9+48], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-748]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-348]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	setb	r8b
	mov	DWORD PTR [r9+52], edx
	xor	eax, eax
	lea	r9, QWORD PTR [r9+80]
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-824]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-424]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9-24], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-820]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-420]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9-20], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-816]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-416]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9-16], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-812]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-412]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9-12], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-808]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-408]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9-8], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	mov	ecx, DWORD PTR [r9-804]
	setb	al
	or	r8d, eax
	mov	eax, DWORD PTR [r9-404]
	lea	edx, DWORD PTR [rax+rcx]
	add	edx, r8d
	xor	r8d, r8d
	cmp	edx, eax
	mov	DWORD PTR [r9-4], edx
	setb	r8b
	xor	eax, eax
	cmp	edx, ecx
	setb	al
	or	r8d, eax
	sub	r10, 1
	jne	$LL19@main

; 23   : 	}
; 24   : 	adc_u32(Num, List, List + Num, List + 2 * Num);
; 25   : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
main	ENDP
_TEXT	ENDS
END
