; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29333.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@		; `string'
PUBLIC	??_C@_06JPHPGKCP@Add?5Eq@			; `string'
PUBLIC	??_C@_07FBEEIGCJ@Add?5Neq@			; `string'
PUBLIC	??_C@_0CD@BPLOBDCO@?$CFs?3?70x?$CF?48llx?0?50x?$CF?48llx?5?$CIans?0?5re@ ; `string'
PUBLIC	??_C@_06KACFJKKE@Mul?5Eq@			; `string'
PUBLIC	??_C@_07CLBBIGHB@Mul?5Neq@			; `string'
PUBLIC	pf4_orders
PUBLIC	pf4
PUBLIC	pf4_factors
EXTRN	__imp_malloc:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__security_check_cookie:PROC
pf4_orders DD	08000H
pf4	DD	010001H
pf4_factors DD	02H
CONST	ENDS
;	COMDAT ??_C@_07CLBBIGHB@Mul?5Neq@
CONST	SEGMENT
??_C@_07CLBBIGHB@Mul?5Neq@ DB 'Mul Neq', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KACFJKKE@Mul?5Eq@
CONST	SEGMENT
??_C@_06KACFJKKE@Mul?5Eq@ DB 'Mul Eq', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BPLOBDCO@?$CFs?3?70x?$CF?48llx?0?50x?$CF?48llx?5?$CIans?0?5re@
CONST	SEGMENT
??_C@_0CD@BPLOBDCO@?$CFs?3?70x?$CF?48llx?0?50x?$CF?48llx?5?$CIans?0?5re@ DB '%'
	DB	's:', 09H, '0x%.8llx, 0x%.8llx (ans, res)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FBEEIGCJ@Add?5Neq@
CONST	SEGMENT
??_C@_07FBEEIGCJ@Add?5Neq@ DB 'Add Neq', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JPHPGKCP@Add?5Eq@
CONST	SEGMENT
??_C@_06JPHPGKCP@Add?5Eq@ DB 'Add Eq', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@
CONST	SEGMENT
??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@ DB 'Generator: %i', 0aH, 00H ; `string'
CONST	ENDS
PUBLIC	main
PUBLIC	fill_list_rand
PUBLIC	vec_mod_pf4
PUBLIC	test_mod_pf4
PUBLIC	search_pf4_gens
PUBLIC	is_pf4_gen
PUBLIC	pow_Zp_ring
PUBLIC	mul_mod_pf4_shr
PUBLIC	add_mod_pf4_shr
PUBLIC	speck64u96
PUBLIC	printf
PUBLIC	_vfprintf_l
PUBLIC	__local_stdio_printf_options
PUBLIC	__isa_available_default
PUBLIC	__xmm@0000ffff0000ffff0000ffff0000ffff
PUBLIC	__xmm@00010000000100000001000000010000
EXTRN	__isa_available:DWORD
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT __isa_available_default
_BSS	SEGMENT
__isa_available_default DD 01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN29
	DD	imagerel $LN29+227
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_list_rand DD imagerel $LN20
	DD	imagerel $LN20+141
	DD	imagerel $unwind$fill_list_rand
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vec_mod_pf4 DD imagerel $LN18
	DD	imagerel $LN18+59
	DD	imagerel $unwind$vec_mod_pf4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$vec_mod_pf4 DD imagerel $LN18+59
	DD	imagerel $LN18+315
	DD	imagerel $chain$2$vec_mod_pf4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$vec_mod_pf4 DD imagerel $LN18+315
	DD	imagerel $LN18+415
	DD	imagerel $chain$3$vec_mod_pf4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$test_mod_pf4 DD imagerel $LN37
	DD	imagerel $LN37+16
	DD	imagerel $unwind$test_mod_pf4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$test_mod_pf4 DD imagerel $LN37+16
	DD	imagerel $LN37+533
	DD	imagerel $chain$3$test_mod_pf4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$test_mod_pf4 DD imagerel $LN37+533
	DD	imagerel $LN37+541
	DD	imagerel $chain$4$test_mod_pf4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$search_pf4_gens DD imagerel $LN35
	DD	imagerel $LN35+19
	DD	imagerel $unwind$search_pf4_gens
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$search_pf4_gens DD imagerel $LN35+19
	DD	imagerel $LN35+218
	DD	imagerel $chain$3$search_pf4_gens
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$search_pf4_gens DD imagerel $LN35+218
	DD	imagerel $LN35+227
	DD	imagerel $chain$4$search_pf4_gens
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_pf4_gen DD imagerel $LN23
	DD	imagerel $LN23+165
	DD	imagerel $unwind$is_pf4_gen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+85
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT __xmm@00010000000100000001000000010000
CONST	SEGMENT
__xmm@00010000000100000001000000010000 DB 00H, 00H, 01H, 00H, 00H, 00H, 01H
	DB	00H, 00H, 00H, 01H, 00H, 00H, 00H, 01H, 00H
CONST	ENDS
;	COMDAT __xmm@0000ffff0000ffff0000ffff0000ffff
CONST	SEGMENT
__xmm@0000ffff0000ffff0000ffff0000ffff DB 0ffH, 0ffH, 00H, 00H, 0ffH, 0ffH
	DB	00H, 00H, 0ffH, 0ffH, 00H, 00H, 0ffH, 0ffH, 00H, 00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_pf4_gen DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$search_pf4_gens DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+19
	DD	imagerel $unwind$search_pf4_gens
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$search_pf4_gens DD 082721H
	DD	04f427H
	DD	0ae41bH
	DD	09540cH
	DD	083405H
	DD	imagerel $LN35
	DD	imagerel $LN35+19
	DD	imagerel $unwind$search_pf4_gens
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$search_pf4_gens DD 030701H
	DD	070034207H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$test_mod_pf4 DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+16
	DD	imagerel $unwind$test_mod_pf4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$test_mod_pf4 DD 081721H
	DD	09e417H
	DD	086412H
	DD	07540dH
	DD	063405H
	DD	imagerel $LN37
	DD	imagerel $LN37+16
	DD	imagerel $unwind$test_mod_pf4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$test_mod_pf4 DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$vec_mod_pf4 DD 021H
	DD	imagerel $LN18
	DD	imagerel $LN18+59
	DD	imagerel $unwind$vec_mod_pf4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$vec_mod_pf4 DD 061821H
	DD	08818H
	DD	01780aH
	DD	026805H
	DD	imagerel $LN18
	DD	imagerel $LN18+59
	DD	imagerel $unwind$vec_mod_pf4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vec_mod_pf4 DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_list_rand DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 642  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, rdx
	mov	rsi, rcx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 644  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 954  :     {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	rbx, rax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;
; 961  :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\speck.h
;	COMDAT speck64u96
_TEXT	SEGMENT
Pt$ = 8
KeyLo$ = 16
KeyHiLo$ = 24
KeyHiHi$ = 32
speck64u96 PROC						; COMDAT

; 11   : 	extern unsigned int _rotl(unsigned int, int);
; 12   : 	extern unsigned int _rotr(unsigned int, int);
; 13   : #define _SPECKXXR(x, y, k) \
; 14   : 	(y = _rotr(x ^ y, 3),  \
; 15   : 		x = _rotl(         \
; 16   : 			(unsigned long long)((x ^ (k)) - y), 8))
; 17   : #define _SPECKXX(Hi, Lo, k)          \
; 18   : 	(Hi = (_rotr(Hi, 8) + Lo) ^ (k), \
; 19   : 		Lo = _rotl(Lo, 3) ^ Hi)
; 20   : 	unsigned int CtHi = Pt >> 32,

	mov	rax, rcx
	shr	rax, 32					; 00000020H

; 21   : 				 CtLo = Pt & 0xffffffffu;
; 22   : 	for(int i = 0; i < 26;)

	xor	r10d, r10d
	npad	6
$LL2@speck64u96:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	eax, 8
	add	eax, ecx
	ror	r8d, 8
	xor	eax, edx
	rol	ecx, 3
	add	r8d, edx
	ror	r9d, 8
	xor	ecx, eax
	rol	edx, 3
	xor	r8d, r10d
	ror	eax, 8
	xor	edx, r8d
	add	eax, ecx
	add	r9d, edx
	rol	ecx, 3
	xor	eax, edx
	inc	r10d
	xor	r9d, r10d
	rol	edx, 3
	xor	edx, r9d
	xor	ecx, eax
	inc	r10d
	cmp	r10d, 26
	jl	SHORT $LL2@speck64u96

; 26   : 			_SPECKXX(KeyHiHi, KeyLo, i++));
; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	shl	rax, 32					; 00000020H
	or	rax, rcx

; 28   : #undef _SPECKXXR
; 29   : #undef _SPECKXX
; 30   : }

	ret	0
speck64u96 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT add_mod_pf4_shr
_TEXT	SEGMENT
a$ = 8
b$ = 16
add_mod_pf4_shr PROC					; COMDAT

; 20   : 	const uint32_t acc = a + b;

	lea	eax, DWORD PTR [rcx+rdx]

; 21   : 	const uint32_t srem

	mov	ecx, eax
	movzx	edx, ax
	shr	ecx, 16
	sub	edx, ecx

; 22   : 		= (acc & 0xffffu) - (acc >> 16);
; 23   : 	const uint32_t rem = srem

	mov	ecx, edx
	mov	eax, edx
	shr	ecx, 15
	and	ecx, 65536				; 00010000H
	shr	eax, 31
	add	ecx, edx
	add	eax, ecx

; 24   : 		+ ((srem & 0x80000000u) >> 15)
; 25   : 		+ ((srem & 0x80000000u) >> 31);
; 26   : 	return rem;
; 27   : }

	ret	0
add_mod_pf4_shr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT mul_mod_pf4_shr
_TEXT	SEGMENT
a$ = 8
b$ = 16
mul_mod_pf4_shr PROC					; COMDAT

; 30   : 	const uint32_t pd_lo = a * b;

	mov	eax, ecx

; 31   : 	const uint32_t pd_hi = a & b & 0x10000u;

	and	ecx, edx
	imul	eax, edx
	and	ecx, 65536				; 00010000H

; 32   : 	const uint32_t srem = (pd_lo & 0xffffu) - pd_hi

	movzx	edx, ax
	sub	edx, ecx
	shr	eax, 16
	sub	edx, eax

; 33   : 		- ((pd_lo & 0xffff0000u) >> 16);
; 34   : 	const uint32_t rem = srem

	mov	ecx, edx
	mov	eax, edx
	shr	ecx, 15
	and	ecx, 65536				; 00010000H
	shr	eax, 31
	add	ecx, edx
	add	eax, ecx

; 35   : 		+ ((srem & 0x80000000u) >> 15)
; 36   : 		+ ((srem & 0x80000000u) >> 31);
; 37   : 	return rem;
; 38   : }

	ret	0
mul_mod_pf4_shr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT pow_Zp_ring
_TEXT	SEGMENT
p$dead$ = 8
base$ = 16
exponent$ = 24
pow_Zp_ring PROC					; COMDAT

; 47   : 	const uint64_t base, const uint64_t exponent) {

	mov	r9, rdx

; 48   : 	uint64_t ans = 1;

	mov	r10d, 1

; 49   : 	for(uint64_t exp = exponent, g = base; exp;) {

	test	r8, r8
	je	SHORT $LN11@pow_Zp_rin
	mov	r11, -281470681808895			; ffff0000ffff0001H
$LL2@pow_Zp_rin:

; 50   : 		if(exp & 1) { ans = (ans * g) % p; }

	test	r8b, 1
	je	SHORT $LN5@pow_Zp_rin
	imul	r10, r9
	mov	rax, r11
	mul	r10
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	r10, rax
$LN5@pow_Zp_rin:

; 51   : 		exp = (exp >> 1);
; 52   : 		g = (g * g) % p;

	mov	rcx, r9
	mov	rax, r11
	imul	rcx, r9
	mul	rcx
	mov	r9, rcx
	shr	rdx, 16
	imul	rcx, rdx, 65537				; 00010001H
	sub	r9, rcx
	shr	r8, 1
	jne	SHORT $LL2@pow_Zp_rin
$LN11@pow_Zp_rin:

; 53   : 	}
; 54   : 	return ans;
; 55   : }

	mov	rax, r10
	ret	0
pow_Zp_ring ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT is_pf4_gen
_TEXT	SEGMENT
a$ = 8
is_pf4_gen PROC						; COMDAT

; 56   : bool is_pf4_gen(const int32_t a) {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi
	movsxd	r11, ecx
	lea	r10, OFFSET FLAT:pf4_orders
	mov	rbx, -281470681808895			; ffff0000ffff0001H
	lea	rdi, OFFSET FLAT:pf4_orders+12
	npad	11
$LL4@is_pf4_gen:

; 58   : 		const uint64_t r

	mov	r8d, DWORD PTR [r10]

; 48   : 	uint64_t ans = 1;

	mov	r9d, 1

; 49   : 	for(uint64_t exp = exponent, g = base; exp;) {

	mov	rcx, r11
	test	r8, r8
	je	SHORT $LN15@is_pf4_gen
$LL8@is_pf4_gen:

; 50   : 		if(exp & 1) { ans = (ans * g) % p; }

	test	r8b, 1
	je	SHORT $LN11@is_pf4_gen
	imul	r9, rcx
	mov	rax, rbx
	mul	r9
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	r9, rax
$LN11@is_pf4_gen:

; 51   : 		exp = (exp >> 1);
; 52   : 		g = (g * g) % p;

	imul	rcx, rcx
	mov	rax, rbx
	mul	rcx
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	rcx, rax
	shr	r8, 1
	jne	SHORT $LL8@is_pf4_gen

; 59   : 			= pow_Zp_ring(0x10001u, a, pf4_orders[i]);
; 60   : 		if(r <= 1) return false;

	cmp	r9, 1
	jbe	SHORT $LN15@is_pf4_gen

; 57   : 	for(int i = 0; i < 3; i++) {

	add	r10, 4
	cmp	r10, rdi
	jl	SHORT $LL4@is_pf4_gen

; 61   : 	}
; 62   : 	return true;

	mov	al, 1

; 63   : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
$LN15@is_pf4_gen:
	mov	rbx, QWORD PTR [rsp+8]
	xor	al, al
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
is_pf4_gen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT search_pf4_gens
_TEXT	SEGMENT
Num$ = 64
search_pf4_gens PROC					; COMDAT

; 64   : int search_pf4_gens(const int Num) {

$LN35:
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 65   : 	for(int i = 0; i < Num; i++) {

	xor	edi, edi
	mov	esi, ecx
	test	ecx, ecx
	jle	$LN33@search_pf4
	mov	QWORD PTR [rsp+64], rbx
	mov	ebx, edi
	mov	QWORD PTR [rsp+72], rbp
	mov	rbp, -281470681808895			; ffff0000ffff0001H
	mov	QWORD PTR [rsp+80], r14
	lea	r14, OFFSET FLAT:pf4_orders+12
	mov	QWORD PTR [rsp+32], r15
	lea	r15, OFFSET FLAT:pf4_orders
$LL4@search_pf4:

; 57   : 	for(int i = 0; i < 3; i++) {

	mov	r10, r15
	npad	12
$LL10@search_pf4:

; 58   : 		const uint64_t r

	mov	r8d, DWORD PTR [r10]

; 48   : 	uint64_t ans = 1;

	mov	r9d, 1

; 49   : 	for(uint64_t exp = exponent, g = base; exp;) {

	mov	rcx, rbx
	test	r8, r8
	je	SHORT $LN2@search_pf4
$LL14@search_pf4:

; 50   : 		if(exp & 1) { ans = (ans * g) % p; }

	test	r8b, 1
	je	SHORT $LN17@search_pf4
	imul	r9, rcx
	mov	rax, rbp
	mul	r9
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	r9, rax
$LN17@search_pf4:

; 51   : 		exp = (exp >> 1);
; 52   : 		g = (g * g) % p;

	imul	rcx, rcx
	mov	rax, rbp
	mul	rcx
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	rcx, rax
	shr	r8, 1
	jne	SHORT $LL14@search_pf4

; 60   : 		if(r <= 1) return false;

	cmp	r9, 1
	jbe	SHORT $LN2@search_pf4

; 53   : 	}
; 54   : 	return ans;
; 55   : }
; 56   : bool is_pf4_gen(const int32_t a) {
; 57   : 	for(int i = 0; i < 3; i++) {

	add	r10, 4
	cmp	r10, r14
	jl	SHORT $LL10@search_pf4

; 66   : 		if(is_pf4_gen(i)) {
; 67   : 			printf("Generator: %i\n", i);

	mov	edx, edi
	lea	rcx, OFFSET FLAT:??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@
	call	printf
$LN2@search_pf4:

; 65   : 	for(int i = 0; i < Num; i++) {

	inc	edi
	inc	rbx
	cmp	edi, esi
	jl	$LL4@search_pf4

; 68   : 		}
; 69   : 	}
; 70   : 	return 0;

	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]
$LN33@search_pf4:

; 71   : }

	xor	eax, eax
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
search_pf4_gens ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT test_mod_pf4
_TEXT	SEGMENT
Num$ = 48
Nonce$ = 56
test_mod_pf4 PROC					; COMDAT

; 72   : int test_mod_pf4(const int Num, const int Nonce) {

$LN37:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, ecx

; 73   : 	if(Num <= 0) return 0;

	test	ecx, ecx
	jle	$LN35@test_mod_p
	mov	QWORD PTR [rsp+48], rbx
	lea	ebx, DWORD PTR [rdx+3]
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], r14
	mov	r14, -281470681808895			; ffff0000ffff0001H
$LL20@test_mod_p:

; 74   : 	const uint64_t a

	lea	eax, DWORD PTR [rbx-3]
	mov	r8d, 99					; 00000063H
	cdqe
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	lea	r10d, DWORD PTR [rbx-3]
	shr	rax, 32					; 00000020H
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 74   : 	const uint64_t a

	lea	r9d, DWORD PTR [rbx+2]
; File C:\Users\user\Desktop\primitive-root\speck.h

; 22   : 	for(int i = 0; i < 26;)

	xor	r11d, r11d
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 74   : 	const uint64_t a

	mov	ecx, ebx
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	mov	edx, r10d
$LL7@test_mod_p:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	eax, 8
	add	eax, edx
	ror	r9d, 8
	xor	eax, ecx
	rol	edx, 3
	add	r9d, ecx
	ror	r8d, 8
	xor	edx, eax
	rol	ecx, 3
	xor	r9d, r11d
	ror	eax, 8
	xor	ecx, r9d
	add	eax, edx
	add	r8d, ecx
	rol	edx, 3
	xor	eax, ecx
	inc	r11d
	xor	r8d, r11d
	rol	ecx, 3
	xor	ecx, r8d
	xor	edx, eax
	inc	r11d
	cmp	r11d, 26
	jl	SHORT $LL7@test_mod_p

; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	mov	r11d, eax
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 77   : 	const uint64_t b

	mov	r8d, 111				; 0000006fH
; File C:\Users\user\Desktop\primitive-root\speck.h

; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	mov	eax, edx
	shl	r11, 32					; 00000020H
	or	r11, rax
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 74   : 	const uint64_t a

	mov	rax, r14
	mul	r11
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H

; 77   : 	const uint64_t b

	lea	edx, DWORD PTR [rbx+13]
	sub	r11, rax
	lea	eax, DWORD PTR [rbx-1]
	movsxd	rcx, eax
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	lea	eax, DWORD PTR [rbx-1]
	shr	rcx, 32					; 00000020H

; 22   : 	for(int i = 0; i < 26;)

	xor	r9d, r9d
	npad	3
$LL12@test_mod_p:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	ecx, 8
	add	ecx, eax
	ror	r8d, 8
	xor	ecx, edx
	rol	eax, 3
	add	r8d, edx
	ror	r10d, 8
	xor	eax, ecx
	rol	edx, 3
	xor	r8d, r9d
	ror	ecx, 8
	xor	edx, r8d
	add	ecx, eax
	add	r10d, edx
	rol	eax, 3
	xor	ecx, edx
	inc	r9d
	xor	r10d, r9d
	rol	edx, 3
	xor	edx, r10d
	xor	eax, ecx
	inc	r9d
	cmp	r9d, 26
	jl	SHORT $LL12@test_mod_p

; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	mov	r8d, ecx
	shl	r8, 32					; 00000020H
	or	r8, rax
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 77   : 	const uint64_t b

	mov	rax, r14
	mul	r8
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	r8, rax

; 78   : 		= speck64u96(Nonce + 2, Nonce + 16, 111, Nonce)
; 79   : 		% 0x10001u;
; 80   : 	const uint64_t add_ans = (a + b) % 0x10001ull;

	mov	rax, r14

; 81   : 	const uint64_t add_res = add_mod_pf4_shr(a, b);
; 82   : 	const uint64_t mul_ans = (a * b) % 0x10001ull;

	mov	rsi, r8
	imul	rsi, r11
	lea	r10, QWORD PTR [r8+r11]
	mul	r10
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	r10, rax

; 20   : 	const uint32_t acc = a + b;

	lea	eax, DWORD PTR [r8+r11]

; 21   : 	const uint32_t srem

	mov	ecx, eax
	movzx	edx, ax
	shr	ecx, 16
	sub	edx, ecx

; 22   : 		= (acc & 0xffffu) - (acc >> 16);
; 23   : 	const uint32_t rem = srem

	mov	eax, edx
	mov	r9d, edx
	shr	eax, 15
	and	eax, 65536				; 00010000H
	shr	r9d, 31
	add	eax, edx
	add	r9d, eax

; 81   : 	const uint64_t add_res = add_mod_pf4_shr(a, b);
; 82   : 	const uint64_t mul_ans = (a * b) % 0x10001ull;

	mov	rax, r14
	mul	rsi
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	rsi, rax

; 30   : 	const uint32_t pd_lo = a * b;

	mov	eax, r8d
	imul	eax, r11d

; 31   : 	const uint32_t pd_hi = a & b & 0x10000u;

	and	r8d, r11d
	and	r8d, 65536				; 00010000H

; 32   : 	const uint32_t srem = (pd_lo & 0xffffu) - pd_hi

	movzx	edx, ax
	shr	eax, 16
	sub	edx, r8d
	sub	edx, eax

; 33   : 		- ((pd_lo & 0xffff0000u) >> 16);
; 34   : 	const uint32_t rem = srem

	mov	eax, edx
	mov	ebp, edx
	shr	eax, 15
	and	eax, 65536				; 00010000H
	shr	ebp, 31
	add	eax, edx
	add	ebp, eax

; 83   : 	const uint64_t mul_res = mul_mod_pf4_shr(a, b);
; 84   : 	if(add_ans != add_res)

	cmp	r10, r9
	je	SHORT $LN3@test_mod_p

; 85   : 		printf("%s:\t0x%.8llx, 0x%.8llx (ans, res)\n",

	mov	r8, r10
	lea	rdx, OFFSET FLAT:??_C@_07FBEEIGCJ@Add?5Neq@
	lea	rcx, OFFSET FLAT:??_C@_0CD@BPLOBDCO@?$CFs?3?70x?$CF?48llx?0?50x?$CF?48llx?5?$CIans?0?5re@
	call	printf
$LN3@test_mod_p:

; 86   : 			(add_ans == add_res ? "Add Eq"
; 87   : 								: "Add Neq"),
; 88   : 			add_ans, add_res);
; 89   : 	if(mul_ans != mul_res)

	cmp	rsi, rbp
	je	SHORT $LN4@test_mod_p

; 90   : 		printf("%s:\t0x%.8llx, 0x%.8llx (ans, res)\n",

	mov	r9, rbp
	lea	rdx, OFFSET FLAT:??_C@_07CLBBIGHB@Mul?5Neq@
	mov	r8, rsi
	lea	rcx, OFFSET FLAT:??_C@_0CD@BPLOBDCO@?$CFs?3?70x?$CF?48llx?0?50x?$CF?48llx?5?$CIans?0?5re@
	call	printf
$LN4@test_mod_p:

; 91   : 			(mul_ans == mul_res ? "Mul Eq"
; 92   : 								: "Mul Neq"),
; 93   : 			mul_ans, mul_res);
; 94   : 	return test_mod_pf4(Num - 1, Nonce + 100001);

	add	ebx, 100001				; 000186a1H
	dec	edi
	test	edi, edi
	jg	$LL20@test_mod_p

; 73   : 	if(Num <= 0) return 0;

	mov	r14, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
$LN35@test_mod_p:

; 95   : }

	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
test_mod_pf4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT vec_mod_pf4
_TEXT	SEGMENT
Num$dead$ = 64
IterRes$ = 72
IterA$ = 80
IterB$ = 88
vec_mod_pf4 PROC					; COMDAT

; 98   : 	int32_t *restrict IterB) {

$LN18:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	r11, r9
	mov	rbx, rdx

; 99   : 	for(int i = 0; i < Num; i++) {

	sub	r11, r8
	sub	rbx, r8
	xor	ecx, ecx
	cmp	DWORD PTR __isa_available, 2
	jl	$LN11@vec_mod_pf
	movdqa	xmm5, XMMWORD PTR __xmm@0000ffff0000ffff0000ffff0000ffff
	mov	eax, 16
	movdqa	xmm4, XMMWORD PTR __xmm@00010000000100000001000000010000
	mov	ecx, 125000				; 0001e848H
	movaps	XMMWORD PTR [rsp+32], xmm6
	movaps	XMMWORD PTR [rsp+16], xmm7
	movd	xmm6, eax
	mov	eax, 15
	movaps	XMMWORD PTR [rsp], xmm8
	movd	xmm7, eax
	mov	eax, 31
	movd	xmm8, eax
	lea	rax, QWORD PTR [r8+16]
	npad	11
$LL4@vec_mod_pf:

; 100  : #if 1
; 101  : 		IterRes[i]
; 102  : 			= mul_mod_pf4_shr(IterA[i], IterB[i]);

	movdqu	xmm0, XMMWORD PTR [r11+rax-16]
	movdqu	xmm1, XMMWORD PTR [rax-16]
	lea	rax, QWORD PTR [rax+32]

; 30   : 	const uint32_t pd_lo = a * b;

	movdqa	xmm2, xmm1

; 31   : 	const uint32_t pd_hi = a & b & 0x10000u;

	pand	xmm1, xmm0
	pand	xmm1, xmm4
	pmulld	xmm2, xmm0

; 32   : 	const uint32_t srem = (pd_lo & 0xffffu) - pd_hi

	movdqa	xmm3, xmm2
	pand	xmm3, xmm5
	psubd	xmm3, xmm1
	psrld	xmm2, xmm6
	psubd	xmm3, xmm2

; 33   : 		- ((pd_lo & 0xffff0000u) >> 16);
; 34   : 	const uint32_t rem = srem

	movdqa	xmm1, xmm3
	movdqa	xmm0, xmm3

; 100  : #if 1
; 101  : 		IterRes[i]
; 102  : 			= mul_mod_pf4_shr(IterA[i], IterB[i]);

	movdqu	xmm2, XMMWORD PTR [r11+rax-32]

; 34   : 	const uint32_t rem = srem

	psrld	xmm1, xmm7
	psrld	xmm0, xmm8
	pand	xmm1, xmm4
	paddd	xmm1, xmm0
	paddd	xmm1, xmm3

; 100  : #if 1
; 101  : 		IterRes[i]
; 102  : 			= mul_mod_pf4_shr(IterA[i], IterB[i]);

	movdqu	xmm0, XMMWORD PTR [rax-32]
	movdqu	XMMWORD PTR [rbx+rax-48], xmm1

; 30   : 	const uint32_t pd_lo = a * b;

	movdqa	xmm1, xmm0
	pmulld	xmm1, xmm2

; 32   : 	const uint32_t srem = (pd_lo & 0xffffu) - pd_hi

	movdqa	xmm3, xmm1
	pand	xmm2, xmm0
	pand	xmm3, xmm5
	pand	xmm2, xmm4
	psubd	xmm3, xmm2
	psrld	xmm1, xmm6
	psubd	xmm3, xmm1

; 33   : 		- ((pd_lo & 0xffff0000u) >> 16);
; 34   : 	const uint32_t rem = srem

	movdqa	xmm1, xmm3
	movdqa	xmm0, xmm3
	psrld	xmm1, xmm7
	psrld	xmm0, xmm8
	pand	xmm1, xmm4
	paddd	xmm1, xmm0
	paddd	xmm1, xmm3

; 100  : #if 1
; 101  : 		IterRes[i]
; 102  : 			= mul_mod_pf4_shr(IterA[i], IterB[i]);

	movdqu	XMMWORD PTR [rbx+rax-32], xmm1
	sub	rcx, 1
	jne	$LL4@vec_mod_pf
	movaps	xmm8, XMMWORD PTR [rsp]
	movaps	xmm7, XMMWORD PTR [rsp+16]
	movaps	xmm6, XMMWORD PTR [rsp+32]

; 103  : #else
; 104  : 		IterRes[i] = (IterA[i] * IterB[i]) % 0x10001u;
; 105  : #endif
; 106  : 	}
; 107  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN11@vec_mod_pf:

; 99   : 	for(int i = 0; i < Num; i++) {

	mov	r10d, 1000000				; 000f4240H
	lea	rax, QWORD PTR [r8+rcx*4]
	sub	r10, rcx
	npad	8
$LL10@vec_mod_pf:

; 100  : #if 1
; 101  : 		IterRes[i]
; 102  : 			= mul_mod_pf4_shr(IterA[i], IterB[i]);

	mov	edx, DWORD PTR [rax]
	lea	rax, QWORD PTR [rax+4]

; 30   : 	const uint32_t pd_lo = a * b;

	mov	r8d, edx

; 31   : 	const uint32_t pd_hi = a & b & 0x10000u;

	and	edx, DWORD PTR [rax+r11-4]
	imul	r8d, DWORD PTR [rax+r11-4]
	and	edx, 65536				; 00010000H

; 32   : 	const uint32_t srem = (pd_lo & 0xffffu) - pd_hi

	movzx	r9d, r8w
	sub	r9d, edx
	shr	r8d, 16
	sub	r9d, r8d

; 33   : 		- ((pd_lo & 0xffff0000u) >> 16);
; 34   : 	const uint32_t rem = srem

	mov	ecx, r9d
	mov	edx, r9d
	shr	ecx, 15
	and	ecx, 65536				; 00010000H
	shr	edx, 31
	add	ecx, r9d
	add	edx, ecx

; 100  : #if 1
; 101  : 		IterRes[i]
; 102  : 			= mul_mod_pf4_shr(IterA[i], IterB[i]);

	mov	DWORD PTR [rax+rbx-4], edx
	sub	r10, 1
	jne	SHORT $LL10@vec_mod_pf

; 103  : #else
; 104  : 		IterRes[i] = (IterA[i] * IterB[i]) % 0x10001u;
; 105  : #endif
; 106  : 	}
; 107  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
vec_mod_pf4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT fill_list_rand
_TEXT	SEGMENT
Num$dead$ = 8
List$ = 16
Nonce$dead$ = 24
fill_list_rand PROC					; COMDAT

; 109  : 	const int Nonce) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	mov	rbx, rdx

; 110  : 	for(int i = 0; i < Num; i++) {

	xor	r11d, r11d
	npad	5
$LL4@fill_list_:
; File C:\Users\user\Desktop\primitive-root\speck.h

; 20   : 	unsigned int CtHi = Pt >> 32,

	xor	eax, eax
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 111  : 		List[i] = (int)speck64u96(

	lea	r9d, DWORD PTR [r11+999999]
; File C:\Users\user\Desktop\primitive-root\speck.h

; 22   : 	for(int i = 0; i < 26;)

	xor	edx, edx
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 111  : 		List[i] = (int)speck64u96(

	mov	r10d, 223344				; 00036870H
	mov	r8d, r11d
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	mov	ecx, 100				; 00000064H
	npad	7
$LL7@fill_list_:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	eax, 8
	add	eax, ecx
	ror	r10d, 8
	xor	eax, r8d
	rol	ecx, 3
	add	r10d, r8d
	ror	r9d, 8
	xor	ecx, eax
	rol	r8d, 3
	xor	r10d, edx
	ror	eax, 8
	xor	r8d, r10d
	add	eax, ecx
	add	r9d, r8d
	rol	ecx, 3
	xor	eax, r8d
	inc	edx
	xor	r9d, edx
	rol	r8d, 3
	xor	r8d, r9d
	xor	ecx, eax
	inc	edx
	cmp	edx, 26
	jl	SHORT $LL7@fill_list_
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 110  : 	for(int i = 0; i < Num; i++) {

	mov	DWORD PTR [rbx], ecx
	inc	r11d
	add	rbx, 4
	cmp	r11d, 3000000				; 002dc6c0H
	jl	SHORT $LL4@fill_list_

; 112  : 			100, i, Nonce, i + 999999);
; 113  : 	}
; 114  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
fill_list_rand ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT main
_TEXT	SEGMENT
main	PROC						; COMDAT

; 115  : int main(void) {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 116  : 	const int VecLen = 1000000;
; 117  : 	int32_t *Vecs

	mov	ecx, 12000000				; 00b71b00H
	call	QWORD PTR __imp_malloc
	mov	rdi, rax
	mov	rbx, rax
	xor	r11d, r11d
	npad	8
$LL9@main:
; File C:\Users\user\Desktop\primitive-root\speck.h

; 20   : 	unsigned int CtHi = Pt >> 32,

	xor	ecx, ecx
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 111  : 		List[i] = (int)speck64u96(

	lea	r9d, DWORD PTR [r11+999999]
; File C:\Users\user\Desktop\primitive-root\speck.h

; 22   : 	for(int i = 0; i < 26;)

	xor	eax, eax
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 111  : 		List[i] = (int)speck64u96(

	mov	r10d, 223344				; 00036870H
	mov	r8d, r11d
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	mov	edx, 100				; 00000064H
	npad	7
$LL12@main:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	ecx, 8
	add	ecx, edx
	ror	r10d, 8
	xor	ecx, r8d
	rol	edx, 3
	add	r10d, r8d
	ror	r9d, 8
	xor	edx, ecx
	rol	r8d, 3
	xor	r10d, eax
	ror	ecx, 8
	xor	r8d, r10d
	add	ecx, edx
	add	r9d, r8d
	rol	edx, 3
	xor	ecx, r8d
	inc	eax
	xor	r9d, eax
	rol	r8d, 3
	xor	r8d, r9d
	xor	edx, ecx
	inc	eax
	cmp	eax, 26
	jl	SHORT $LL12@main
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 110  : 	for(int i = 0; i < Num; i++) {

	mov	DWORD PTR [rbx], edx
	inc	r11d
	add	rbx, 4
	cmp	r11d, 3000000				; 002dc6c0H
	jl	SHORT $LL9@main

; 118  : 		= malloc(VecLen * 3 * sizeof Vecs[0]);
; 119  : 	fill_list_rand(VecLen * 3, Vecs, 223344);
; 120  : 	for(int i = 0; i < 1000; i++) {

	mov	ebx, 1000				; 000003e8H
	npad	4
$LL4@main:

; 121  : 		vec_mod_pf4(VecLen, Vecs, Vecs + VecLen,

	lea	r9, QWORD PTR [rdi+8000000]
	mov	rdx, rdi
	lea	r8, QWORD PTR [rdi+4000000]
	call	vec_mod_pf4
	sub	rbx, 1
	jne	SHORT $LL4@main

; 122  : 			Vecs + VecLen * 2);
; 123  : 	}
; 124  : 	return 0;
; 125  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
main	ENDP
_TEXT	ENDS
END
