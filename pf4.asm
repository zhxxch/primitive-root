; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29333.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@		; `string'
PUBLIC	??_C@_06JPHPGKCP@Add?5Eq@			; `string'
PUBLIC	??_C@_07FBEEIGCJ@Add?5Neq@			; `string'
PUBLIC	??_C@_0CD@BPLOBDCO@?$CFs?3?70x?$CF?48llx?0?50x?$CF?48llx?5?$CIans?0?5re@ ; `string'
PUBLIC	??_C@_06KACFJKKE@Mul?5Eq@			; `string'
PUBLIC	??_C@_07CLBBIGHB@Mul?5Neq@			; `string'
PUBLIC	pf4_orders
PUBLIC	pf4
PUBLIC	pf4_factors
EXTRN	__imp_malloc:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__security_check_cookie:PROC
pf4_orders DD	08000H
pf4	DD	010001H
pf4_factors DD	02H
CONST	ENDS
;	COMDAT ??_C@_07CLBBIGHB@Mul?5Neq@
CONST	SEGMENT
??_C@_07CLBBIGHB@Mul?5Neq@ DB 'Mul Neq', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06KACFJKKE@Mul?5Eq@
CONST	SEGMENT
??_C@_06KACFJKKE@Mul?5Eq@ DB 'Mul Eq', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BPLOBDCO@?$CFs?3?70x?$CF?48llx?0?50x?$CF?48llx?5?$CIans?0?5re@
CONST	SEGMENT
??_C@_0CD@BPLOBDCO@?$CFs?3?70x?$CF?48llx?0?50x?$CF?48llx?5?$CIans?0?5re@ DB '%'
	DB	's:', 09H, '0x%.8llx, 0x%.8llx (ans, res)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07FBEEIGCJ@Add?5Neq@
CONST	SEGMENT
??_C@_07FBEEIGCJ@Add?5Neq@ DB 'Add Neq', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06JPHPGKCP@Add?5Eq@
CONST	SEGMENT
??_C@_06JPHPGKCP@Add?5Eq@ DB 'Add Eq', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@
CONST	SEGMENT
??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@ DB 'Generator: %i', 0aH, 00H ; `string'
CONST	ENDS
PUBLIC	main
PUBLIC	fill_list_rand
PUBLIC	vec_mod_pf4
PUBLIC	test_mod_pf4
PUBLIC	search_pf4_gens
PUBLIC	is_pf4_gen
PUBLIC	pow_Zp_ring
PUBLIC	mul_mod_pf4_shr
PUBLIC	add_mod_pf4_shr
PUBLIC	speck64u96
PUBLIC	printf
PUBLIC	_vfprintf_l
PUBLIC	__local_stdio_printf_options
PUBLIC	__ymm@0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff
PUBLIC	__ymm@0001000000010000000100000001000000010000000100000001000000010000
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN29
	DD	imagerel $LN29+210
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_list_rand DD imagerel $LN20
	DD	imagerel $LN20+141
	DD	imagerel $unwind$fill_list_rand
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vec_mod_pf4 DD imagerel $LN18
	DD	imagerel $LN18+296
	DD	imagerel $unwind$vec_mod_pf4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$test_mod_pf4 DD imagerel $LN37
	DD	imagerel $LN37+16
	DD	imagerel $unwind$test_mod_pf4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$test_mod_pf4 DD imagerel $LN37+16
	DD	imagerel $LN37+533
	DD	imagerel $chain$3$test_mod_pf4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$test_mod_pf4 DD imagerel $LN37+533
	DD	imagerel $LN37+541
	DD	imagerel $chain$4$test_mod_pf4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$search_pf4_gens DD imagerel $LN35
	DD	imagerel $LN35+19
	DD	imagerel $unwind$search_pf4_gens
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$search_pf4_gens DD imagerel $LN35+19
	DD	imagerel $LN35+218
	DD	imagerel $chain$3$search_pf4_gens
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$search_pf4_gens DD imagerel $LN35+218
	DD	imagerel $LN35+227
	DD	imagerel $chain$4$search_pf4_gens
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_pf4_gen DD imagerel $LN23
	DD	imagerel $LN23+165
	DD	imagerel $unwind$is_pf4_gen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+85
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT __ymm@0001000000010000000100000001000000010000000100000001000000010000
CONST	SEGMENT
__ymm@0001000000010000000100000001000000010000000100000001000000010000 DB 00H
	DB	00H, 01H, 00H, 00H, 00H, 01H, 00H, 00H, 00H, 01H, 00H, 00H, 00H
	DB	01H, 00H, 00H, 00H, 01H, 00H, 00H, 00H, 01H, 00H, 00H, 00H, 01H
	DB	00H, 00H, 00H, 01H, 00H
CONST	ENDS
;	COMDAT __ymm@0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff
CONST	SEGMENT
__ymm@0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff DB 0ffH
	DB	0ffH, 00H, 00H, 0ffH, 0ffH, 00H, 00H, 0ffH, 0ffH, 00H, 00H, 0ffH
	DB	0ffH, 00H, 00H, 0ffH, 0ffH, 00H, 00H, 0ffH, 0ffH, 00H, 00H, 0ffH
	DB	0ffH, 00H, 00H, 0ffH, 0ffH, 00H, 00H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_pf4_gen DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$search_pf4_gens DD 021H
	DD	imagerel $LN35
	DD	imagerel $LN35+19
	DD	imagerel $unwind$search_pf4_gens
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$search_pf4_gens DD 082721H
	DD	04f427H
	DD	0ae41bH
	DD	09540cH
	DD	083405H
	DD	imagerel $LN35
	DD	imagerel $LN35+19
	DD	imagerel $unwind$search_pf4_gens
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$search_pf4_gens DD 030701H
	DD	070034207H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$test_mod_pf4 DD 021H
	DD	imagerel $LN37
	DD	imagerel $LN37+16
	DD	imagerel $unwind$test_mod_pf4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$test_mod_pf4 DD 081721H
	DD	09e417H
	DD	086412H
	DD	07540dH
	DD	063405H
	DD	imagerel $LN37
	DD	imagerel $LN37+16
	DD	imagerel $unwind$test_mod_pf4
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$test_mod_pf4 DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vec_mod_pf4 DD 0b2801H
	DD	08981fH
	DD	09881aH
	DD	0a7815H
	DD	0b6810H
	DD	018010bH
	DD	05004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_list_rand DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 642  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, rdx
	mov	rsi, rcx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 644  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 954  :     {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	rbx, rax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;
; 961  :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\speck.h
;	COMDAT speck64u96
_TEXT	SEGMENT
Pt$ = 8
KeyLo$ = 16
KeyHiLo$ = 24
KeyHiHi$ = 32
speck64u96 PROC						; COMDAT

; 11   : 	extern unsigned int _rotl(unsigned int, int);
; 12   : 	extern unsigned int _rotr(unsigned int, int);
; 13   : #define _SPECKXXR(x, y, k) \
; 14   : 	(y = _rotr(x ^ y, 3),  \
; 15   : 		x = _rotl(         \
; 16   : 			(unsigned long long)((x ^ (k)) - y), 8))
; 17   : #define _SPECKXX(Hi, Lo, k)          \
; 18   : 	(Hi = (_rotr(Hi, 8) + Lo) ^ (k), \
; 19   : 		Lo = _rotl(Lo, 3) ^ Hi)
; 20   : 	unsigned int CtHi = Pt >> 32,

	mov	rax, rcx
	shr	rax, 32					; 00000020H

; 21   : 				 CtLo = Pt & 0xffffffffu;
; 22   : 	for(int i = 0; i < 26;)

	xor	r10d, r10d
	npad	6
$LL2@speck64u96:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	eax, 8
	add	eax, ecx
	ror	r8d, 8
	xor	eax, edx
	rol	ecx, 3
	add	r8d, edx
	ror	r9d, 8
	xor	ecx, eax
	rol	edx, 3
	xor	r8d, r10d
	ror	eax, 8
	xor	edx, r8d
	add	eax, ecx
	add	r9d, edx
	rol	ecx, 3
	xor	eax, edx
	inc	r10d
	xor	r9d, r10d
	rol	edx, 3
	xor	edx, r9d
	xor	ecx, eax
	inc	r10d
	cmp	r10d, 26
	jl	SHORT $LL2@speck64u96

; 26   : 			_SPECKXX(KeyHiHi, KeyLo, i++));
; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	shl	rax, 32					; 00000020H
	or	rax, rcx

; 28   : #undef _SPECKXXR
; 29   : #undef _SPECKXX
; 30   : }

	ret	0
speck64u96 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT add_mod_pf4_shr
_TEXT	SEGMENT
a$ = 8
b$ = 16
add_mod_pf4_shr PROC					; COMDAT

; 20   : 	const uint32_t acc = a + b;

	lea	eax, DWORD PTR [rcx+rdx]

; 21   : 	const uint32_t srem

	mov	ecx, eax
	movzx	edx, ax
	shr	ecx, 16
	sub	edx, ecx

; 22   : 		= (acc & 0xffffu) - (acc >> 16);
; 23   : 	const uint32_t rem = srem

	mov	ecx, edx
	mov	eax, edx
	shr	ecx, 15
	and	ecx, 65536				; 00010000H
	shr	eax, 31
	add	ecx, edx
	add	eax, ecx

; 24   : 		+ ((srem & 0x80000000u) >> 15)
; 25   : 		+ ((srem & 0x80000000u) >> 31);
; 26   : 	return rem;
; 27   : }

	ret	0
add_mod_pf4_shr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT mul_mod_pf4_shr
_TEXT	SEGMENT
a$ = 8
b$ = 16
mul_mod_pf4_shr PROC					; COMDAT

; 30   : 	const uint32_t pd_lo = a * b;

	mov	eax, ecx

; 31   : 	const uint32_t pd_hi = a & b & 0x10000u;

	and	ecx, edx
	imul	eax, edx
	and	ecx, 65536				; 00010000H

; 32   : 	const uint32_t srem = (pd_lo & 0xffffu) - pd_hi

	movzx	edx, ax
	sub	edx, ecx
	shr	eax, 16
	sub	edx, eax

; 33   : 		- ((pd_lo & 0xffff0000u) >> 16);
; 34   : 	const uint32_t rem = srem

	mov	ecx, edx
	mov	eax, edx
	shr	ecx, 15
	and	ecx, 65536				; 00010000H
	shr	eax, 31
	add	ecx, edx
	add	eax, ecx

; 35   : 		+ ((srem & 0x80000000u) >> 15)
; 36   : 		+ ((srem & 0x80000000u) >> 31);
; 37   : 	return rem;
; 38   : }

	ret	0
mul_mod_pf4_shr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT pow_Zp_ring
_TEXT	SEGMENT
p$dead$ = 8
base$ = 16
exponent$ = 24
pow_Zp_ring PROC					; COMDAT

; 47   : 	const uint64_t base, const uint64_t exponent) {

	mov	r9, rdx

; 48   : 	uint64_t ans = 1;

	mov	r10d, 1

; 49   : 	for(uint64_t exp = exponent, g = base; exp;) {

	test	r8, r8
	je	SHORT $LN11@pow_Zp_rin
	mov	r11, -281470681808895			; ffff0000ffff0001H
$LL2@pow_Zp_rin:

; 50   : 		if(exp & 1) { ans = (ans * g) % p; }

	test	r8b, 1
	je	SHORT $LN5@pow_Zp_rin
	imul	r10, r9
	mov	rax, r11
	mul	r10
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	r10, rax
$LN5@pow_Zp_rin:

; 51   : 		exp = (exp >> 1);
; 52   : 		g = (g * g) % p;

	mov	rcx, r9
	mov	rax, r11
	imul	rcx, r9
	mul	rcx
	mov	r9, rcx
	shr	rdx, 16
	imul	rcx, rdx, 65537				; 00010001H
	sub	r9, rcx
	shr	r8, 1
	jne	SHORT $LL2@pow_Zp_rin
$LN11@pow_Zp_rin:

; 53   : 	}
; 54   : 	return ans;
; 55   : }

	mov	rax, r10
	ret	0
pow_Zp_ring ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT is_pf4_gen
_TEXT	SEGMENT
a$ = 8
is_pf4_gen PROC						; COMDAT

; 56   : bool is_pf4_gen(const int32_t a) {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi
	movsxd	r11, ecx
	lea	r10, OFFSET FLAT:pf4_orders
	mov	rbx, -281470681808895			; ffff0000ffff0001H
	lea	rdi, OFFSET FLAT:pf4_orders+12
	npad	11
$LL4@is_pf4_gen:

; 58   : 		const uint64_t r

	mov	r8d, DWORD PTR [r10]

; 48   : 	uint64_t ans = 1;

	mov	r9d, 1

; 49   : 	for(uint64_t exp = exponent, g = base; exp;) {

	mov	rcx, r11
	test	r8, r8
	je	SHORT $LN15@is_pf4_gen
$LL8@is_pf4_gen:

; 50   : 		if(exp & 1) { ans = (ans * g) % p; }

	test	r8b, 1
	je	SHORT $LN11@is_pf4_gen
	imul	r9, rcx
	mov	rax, rbx
	mul	r9
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	r9, rax
$LN11@is_pf4_gen:

; 51   : 		exp = (exp >> 1);
; 52   : 		g = (g * g) % p;

	imul	rcx, rcx
	mov	rax, rbx
	mul	rcx
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	rcx, rax
	shr	r8, 1
	jne	SHORT $LL8@is_pf4_gen

; 59   : 			= pow_Zp_ring(0x10001u, a, pf4_orders[i]);
; 60   : 		if(r <= 1) return false;

	cmp	r9, 1
	jbe	SHORT $LN15@is_pf4_gen

; 57   : 	for(int i = 0; i < 3; i++) {

	add	r10, 4
	cmp	r10, rdi
	jl	SHORT $LL4@is_pf4_gen

; 61   : 	}
; 62   : 	return true;

	mov	al, 1

; 63   : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
$LN15@is_pf4_gen:
	mov	rbx, QWORD PTR [rsp+8]
	xor	al, al
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
is_pf4_gen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT search_pf4_gens
_TEXT	SEGMENT
Num$ = 64
search_pf4_gens PROC					; COMDAT

; 64   : int search_pf4_gens(const int Num) {

$LN35:
	push	rsi
	push	rdi
	sub	rsp, 40					; 00000028H

; 65   : 	for(int i = 0; i < Num; i++) {

	xor	edi, edi
	mov	esi, ecx
	test	ecx, ecx
	jle	$LN33@search_pf4
	mov	QWORD PTR [rsp+64], rbx
	mov	ebx, edi
	mov	QWORD PTR [rsp+72], rbp
	mov	rbp, -281470681808895			; ffff0000ffff0001H
	mov	QWORD PTR [rsp+80], r14
	lea	r14, OFFSET FLAT:pf4_orders+12
	mov	QWORD PTR [rsp+32], r15
	lea	r15, OFFSET FLAT:pf4_orders
$LL4@search_pf4:

; 57   : 	for(int i = 0; i < 3; i++) {

	mov	r10, r15
	npad	12
$LL10@search_pf4:

; 58   : 		const uint64_t r

	mov	r8d, DWORD PTR [r10]

; 48   : 	uint64_t ans = 1;

	mov	r9d, 1

; 49   : 	for(uint64_t exp = exponent, g = base; exp;) {

	mov	rcx, rbx
	test	r8, r8
	je	SHORT $LN2@search_pf4
$LL14@search_pf4:

; 50   : 		if(exp & 1) { ans = (ans * g) % p; }

	test	r8b, 1
	je	SHORT $LN17@search_pf4
	imul	r9, rcx
	mov	rax, rbp
	mul	r9
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	r9, rax
$LN17@search_pf4:

; 51   : 		exp = (exp >> 1);
; 52   : 		g = (g * g) % p;

	imul	rcx, rcx
	mov	rax, rbp
	mul	rcx
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	rcx, rax
	shr	r8, 1
	jne	SHORT $LL14@search_pf4

; 60   : 		if(r <= 1) return false;

	cmp	r9, 1
	jbe	SHORT $LN2@search_pf4

; 53   : 	}
; 54   : 	return ans;
; 55   : }
; 56   : bool is_pf4_gen(const int32_t a) {
; 57   : 	for(int i = 0; i < 3; i++) {

	add	r10, 4
	cmp	r10, r14
	jl	SHORT $LL10@search_pf4

; 66   : 		if(is_pf4_gen(i)) {
; 67   : 			printf("Generator: %i\n", i);

	mov	edx, edi
	lea	rcx, OFFSET FLAT:??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@
	call	printf
$LN2@search_pf4:

; 65   : 	for(int i = 0; i < Num; i++) {

	inc	edi
	inc	rbx
	cmp	edi, esi
	jl	$LL4@search_pf4

; 68   : 		}
; 69   : 	}
; 70   : 	return 0;

	mov	r15, QWORD PTR [rsp+32]
	mov	r14, QWORD PTR [rsp+80]
	mov	rbp, QWORD PTR [rsp+72]
	mov	rbx, QWORD PTR [rsp+64]
$LN33@search_pf4:

; 71   : }

	xor	eax, eax
	add	rsp, 40					; 00000028H
	pop	rdi
	pop	rsi
	ret	0
search_pf4_gens ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT test_mod_pf4
_TEXT	SEGMENT
Num$ = 48
Nonce$ = 56
test_mod_pf4 PROC					; COMDAT

; 72   : int test_mod_pf4(const int Num, const int Nonce) {

$LN37:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, ecx

; 73   : 	if(Num <= 0) return 0;

	test	ecx, ecx
	jle	$LN35@test_mod_p
	mov	QWORD PTR [rsp+48], rbx
	lea	ebx, DWORD PTR [rdx+3]
	mov	QWORD PTR [rsp+56], rbp
	mov	QWORD PTR [rsp+64], rsi
	mov	QWORD PTR [rsp+72], r14
	mov	r14, -281470681808895			; ffff0000ffff0001H
$LL20@test_mod_p:

; 74   : 	const uint64_t a

	lea	eax, DWORD PTR [rbx-3]
	mov	r8d, 99					; 00000063H
	cdqe
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	lea	r10d, DWORD PTR [rbx-3]
	shr	rax, 32					; 00000020H
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 74   : 	const uint64_t a

	lea	r9d, DWORD PTR [rbx+2]
; File C:\Users\user\Desktop\primitive-root\speck.h

; 22   : 	for(int i = 0; i < 26;)

	xor	r11d, r11d
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 74   : 	const uint64_t a

	mov	ecx, ebx
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	mov	edx, r10d
$LL7@test_mod_p:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	eax, 8
	add	eax, edx
	ror	r9d, 8
	xor	eax, ecx
	rol	edx, 3
	add	r9d, ecx
	ror	r8d, 8
	xor	edx, eax
	rol	ecx, 3
	xor	r9d, r11d
	ror	eax, 8
	xor	ecx, r9d
	add	eax, edx
	add	r8d, ecx
	rol	edx, 3
	xor	eax, ecx
	inc	r11d
	xor	r8d, r11d
	rol	ecx, 3
	xor	ecx, r8d
	xor	edx, eax
	inc	r11d
	cmp	r11d, 26
	jl	SHORT $LL7@test_mod_p

; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	mov	r11d, eax
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 77   : 	const uint64_t b

	mov	r8d, 111				; 0000006fH
; File C:\Users\user\Desktop\primitive-root\speck.h

; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	mov	eax, edx
	shl	r11, 32					; 00000020H
	or	r11, rax
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 74   : 	const uint64_t a

	mov	rax, r14
	mul	r11
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H

; 77   : 	const uint64_t b

	lea	edx, DWORD PTR [rbx+13]
	sub	r11, rax
	lea	eax, DWORD PTR [rbx-1]
	movsxd	rcx, eax
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	lea	eax, DWORD PTR [rbx-1]
	shr	rcx, 32					; 00000020H

; 22   : 	for(int i = 0; i < 26;)

	xor	r9d, r9d
	npad	3
$LL12@test_mod_p:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	ecx, 8
	add	ecx, eax
	ror	r8d, 8
	xor	ecx, edx
	rol	eax, 3
	add	r8d, edx
	ror	r10d, 8
	xor	eax, ecx
	rol	edx, 3
	xor	r8d, r9d
	ror	ecx, 8
	xor	edx, r8d
	add	ecx, eax
	add	r10d, edx
	rol	eax, 3
	xor	ecx, edx
	inc	r9d
	xor	r10d, r9d
	rol	edx, 3
	xor	edx, r10d
	xor	eax, ecx
	inc	r9d
	cmp	r9d, 26
	jl	SHORT $LL12@test_mod_p

; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	mov	r8d, ecx
	shl	r8, 32					; 00000020H
	or	r8, rax
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 77   : 	const uint64_t b

	mov	rax, r14
	mul	r8
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	r8, rax

; 78   : 		= speck64u96(Nonce + 2, Nonce + 16, 111, Nonce)
; 79   : 		% 0x10001u;
; 80   : 	const uint64_t add_ans = (a + b) % 0x10001ull;

	mov	rax, r14

; 81   : 	const uint64_t add_res = add_mod_pf4_shr(a, b);
; 82   : 	const uint64_t mul_ans = (a * b) % 0x10001ull;

	mov	rsi, r8
	imul	rsi, r11
	lea	r10, QWORD PTR [r8+r11]
	mul	r10
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	r10, rax

; 20   : 	const uint32_t acc = a + b;

	lea	eax, DWORD PTR [r8+r11]

; 21   : 	const uint32_t srem

	mov	ecx, eax
	movzx	edx, ax
	shr	ecx, 16
	sub	edx, ecx

; 22   : 		= (acc & 0xffffu) - (acc >> 16);
; 23   : 	const uint32_t rem = srem

	mov	eax, edx
	mov	r9d, edx
	shr	eax, 15
	and	eax, 65536				; 00010000H
	shr	r9d, 31
	add	eax, edx
	add	r9d, eax

; 81   : 	const uint64_t add_res = add_mod_pf4_shr(a, b);
; 82   : 	const uint64_t mul_ans = (a * b) % 0x10001ull;

	mov	rax, r14
	mul	rsi
	shr	rdx, 16
	imul	rax, rdx, 65537				; 00010001H
	sub	rsi, rax

; 30   : 	const uint32_t pd_lo = a * b;

	mov	eax, r8d
	imul	eax, r11d

; 31   : 	const uint32_t pd_hi = a & b & 0x10000u;

	and	r8d, r11d
	and	r8d, 65536				; 00010000H

; 32   : 	const uint32_t srem = (pd_lo & 0xffffu) - pd_hi

	movzx	edx, ax
	shr	eax, 16
	sub	edx, r8d
	sub	edx, eax

; 33   : 		- ((pd_lo & 0xffff0000u) >> 16);
; 34   : 	const uint32_t rem = srem

	mov	eax, edx
	mov	ebp, edx
	shr	eax, 15
	and	eax, 65536				; 00010000H
	shr	ebp, 31
	add	eax, edx
	add	ebp, eax

; 83   : 	const uint64_t mul_res = mul_mod_pf4_shr(a, b);
; 84   : 	if(add_ans != add_res)

	cmp	r10, r9
	je	SHORT $LN3@test_mod_p

; 85   : 		printf("%s:\t0x%.8llx, 0x%.8llx (ans, res)\n",

	mov	r8, r10
	lea	rdx, OFFSET FLAT:??_C@_07FBEEIGCJ@Add?5Neq@
	lea	rcx, OFFSET FLAT:??_C@_0CD@BPLOBDCO@?$CFs?3?70x?$CF?48llx?0?50x?$CF?48llx?5?$CIans?0?5re@
	call	printf
$LN3@test_mod_p:

; 86   : 			(add_ans == add_res ? "Add Eq"
; 87   : 								: "Add Neq"),
; 88   : 			add_ans, add_res);
; 89   : 	if(mul_ans != mul_res)

	cmp	rsi, rbp
	je	SHORT $LN4@test_mod_p

; 90   : 		printf("%s:\t0x%.8llx, 0x%.8llx (ans, res)\n",

	mov	r9, rbp
	lea	rdx, OFFSET FLAT:??_C@_07CLBBIGHB@Mul?5Neq@
	mov	r8, rsi
	lea	rcx, OFFSET FLAT:??_C@_0CD@BPLOBDCO@?$CFs?3?70x?$CF?48llx?0?50x?$CF?48llx?5?$CIans?0?5re@
	call	printf
$LN4@test_mod_p:

; 91   : 			(mul_ans == mul_res ? "Mul Eq"
; 92   : 								: "Mul Neq"),
; 93   : 			mul_ans, mul_res);
; 94   : 	return test_mod_pf4(Num - 1, Nonce + 100001);

	add	ebx, 100001				; 000186a1H
	dec	edi
	test	edi, edi
	jg	$LL20@test_mod_p

; 73   : 	if(Num <= 0) return 0;

	mov	r14, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
$LN35@test_mod_p:

; 95   : }

	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
test_mod_pf4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT vec_mod_pf4
_TEXT	SEGMENT
tv167 = 0
tv173 = 32
tv176 = 64
Num$dead$ = 208
IterRes$ = 216
IterA$ = 224
IterB$ = 232
vec_mod_pf4 PROC					; COMDAT

; 99   : 	uint16_t *restrict IterB) {

$LN18:
	mov	rax, rsp
	push	rbp
	sub	rsp, 192				; 000000c0H
	vmovaps	XMMWORD PTR [rax-24], xmm6
	vmovaps	XMMWORD PTR [rax-40], xmm7
	vmovaps	XMMWORD PTR [rax-56], xmm8
	vmovaps	XMMWORD PTR [rax-72], xmm9
	lea	rbp, QWORD PTR [rsp+32]
	and	rbp, -32				; ffffffffffffffe0H
	vmovdqu	ymm5, YMMWORD PTR __ymm@0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff
	vmovdqu	ymm6, YMMWORD PTR __ymm@0001000000010000000100000001000000010000000100000001000000010000
	mov	eax, 16

; 100  : 	for(int i = 0; i < Num; i++) {

	xor	ecx, ecx
	vmovd	xmm2, eax
	mov	eax, 31
	sub	r9, r8

; 21   : 	const uint32_t srem

	vmovdqu	YMMWORD PTR tv167[rbp], ymm2

; 100  : 	for(int i = 0; i < Num; i++) {

	vmovdqu	xmm7, XMMWORD PTR tv167[rbp]
	vmovd	xmm2, eax
	mov	eax, 15

; 23   : 	const uint32_t rem = srem

	vmovdqu	YMMWORD PTR tv173[rbp], ymm2

; 100  : 	for(int i = 0; i < Num; i++) {

	vmovdqu	xmm8, XMMWORD PTR tv173[rbp]
	vmovd	xmm2, eax

; 23   : 	const uint32_t rem = srem

	vmovdqu	YMMWORD PTR tv176[rbp], ymm2

; 100  : 	for(int i = 0; i < Num; i++) {

	vmovdqu	xmm9, XMMWORD PTR tv176[rbp]
	lea	rax, QWORD PTR [r8+16]
	npad	6
$LL4@vec_mod_pf:

; 101  : #if 1
; 102  : 		IterRes[i]
; 103  : 			= add_mod_pf4_shr(IterA[i], IterB[i]);

	vpmovzxwd ymm2, XMMWORD PTR [rax-16]
	vpmovzxwd ymm0, XMMWORD PTR [r9+rax-16]

; 20   : 	const uint32_t acc = a + b;

	vpaddd	ymm3, ymm0, ymm2

; 21   : 	const uint32_t srem

	vpand	ymm1, ymm3, ymm5
	vpsrld	ymm0, ymm3, xmm7
	vpsubd	ymm4, ymm1, ymm0

; 22   : 		= (acc & 0xffffu) - (acc >> 16);
; 23   : 	const uint32_t rem = srem

	vpsrld	ymm0, ymm4, xmm9
	vpand	ymm1, ymm0, ymm6

; 101  : #if 1
; 102  : 		IterRes[i]
; 103  : 			= add_mod_pf4_shr(IterA[i], IterB[i]);

	vpmovzxwd ymm0, XMMWORD PTR [r9+rax]

; 23   : 	const uint32_t rem = srem

	vpsrld	ymm2, ymm4, xmm8
	vpaddd	ymm2, ymm1, ymm2
	vpaddd	ymm3, ymm2, ymm4

; 101  : #if 1
; 102  : 		IterRes[i]
; 103  : 			= add_mod_pf4_shr(IterA[i], IterB[i]);

	vpmovzxwd ymm2, XMMWORD PTR [rax]

; 20   : 	const uint32_t acc = a + b;

	vpaddd	ymm2, ymm0, ymm2

; 21   : 	const uint32_t srem

	vpand	ymm1, ymm2, ymm5
	vpsrld	ymm0, ymm2, xmm7

; 101  : #if 1
; 102  : 		IterRes[i]
; 103  : 			= add_mod_pf4_shr(IterA[i], IterB[i]);

	vmovdqu	YMMWORD PTR [rdx+rcx*4], ymm3

; 21   : 	const uint32_t srem

	vpsubd	ymm3, ymm1, ymm0

; 22   : 		= (acc & 0xffffu) - (acc >> 16);
; 23   : 	const uint32_t rem = srem

	vpsrld	ymm0, ymm3, xmm9
	vpsrld	ymm2, ymm3, xmm8
	vpand	ymm1, ymm0, ymm6
	vpaddd	ymm2, ymm1, ymm2
	vpaddd	ymm3, ymm2, ymm3

; 101  : #if 1
; 102  : 		IterRes[i]
; 103  : 			= add_mod_pf4_shr(IterA[i], IterB[i]);

	vmovdqu	YMMWORD PTR [rdx+rcx*4+32], ymm3
	add	rcx, 16
	lea	rax, QWORD PTR [rax+32]
	cmp	rcx, 1000000				; 000f4240H
	jl	SHORT $LL4@vec_mod_pf
	vzeroupper

; 104  : #else
; 105  : 		IterRes[i]
; 106  : 			= ((uint32_t)IterA[i] + (uint32_t)IterB[i])
; 107  : 			% 0x10001u;
; 108  : #endif
; 109  : 	}
; 110  : }

	lea	r11, QWORD PTR [rsp+192]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	vmovaps	xmm8, XMMWORD PTR [r11-48]
	vmovaps	xmm9, XMMWORD PTR [r11-64]
	mov	rsp, r11
	pop	rbp
	ret	0
vec_mod_pf4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT fill_list_rand
_TEXT	SEGMENT
Num$dead$ = 8
List$ = 16
Nonce$dead$ = 24
fill_list_rand PROC					; COMDAT

; 112  : 	uint32_t *restrict List, const int Nonce) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	mov	rbx, rdx

; 113  : 	for(int i = 0; i < Num; i++) {

	xor	r11d, r11d
	npad	5
$LL4@fill_list_:
; File C:\Users\user\Desktop\primitive-root\speck.h

; 20   : 	unsigned int CtHi = Pt >> 32,

	xor	eax, eax
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 114  : 		List[i] = (int)speck64u96(

	lea	r9d, DWORD PTR [r11+999999]
; File C:\Users\user\Desktop\primitive-root\speck.h

; 22   : 	for(int i = 0; i < 26;)

	xor	edx, edx
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 114  : 		List[i] = (int)speck64u96(

	mov	r10d, 223344				; 00036870H
	mov	r8d, r11d
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	mov	ecx, 100				; 00000064H
	npad	7
$LL7@fill_list_:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	eax, 8
	add	eax, ecx
	ror	r10d, 8
	xor	eax, r8d
	rol	ecx, 3
	add	r10d, r8d
	ror	r9d, 8
	xor	ecx, eax
	rol	r8d, 3
	xor	r10d, edx
	ror	eax, 8
	xor	r8d, r10d
	add	eax, ecx
	add	r9d, r8d
	rol	ecx, 3
	xor	eax, r8d
	inc	edx
	xor	r9d, edx
	rol	r8d, 3
	xor	r8d, r9d
	xor	ecx, eax
	inc	edx
	cmp	edx, 26
	jl	SHORT $LL7@fill_list_
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 113  : 	for(int i = 0; i < Num; i++) {

	mov	DWORD PTR [rbx], ecx
	inc	r11d
	add	rbx, 4
	cmp	r11d, 3000000				; 002dc6c0H
	jl	SHORT $LL4@fill_list_

; 115  : 			100, i, Nonce, i + 999999);
; 116  : 	}
; 117  : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
fill_list_rand ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\pf4.c
;	COMDAT main
_TEXT	SEGMENT
main	PROC						; COMDAT

; 118  : int main(void) {

$LN29:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 119  : 	const int VecLen = 1000000;
; 120  : 	uint32_t *Vecs

	mov	ecx, 12000000				; 00b71b00H
	call	QWORD PTR __imp_malloc
	mov	rdi, rax
	mov	rbx, rax
	xor	r11d, r11d
	npad	2
$LL9@main:
; File C:\Users\user\Desktop\primitive-root\speck.h

; 20   : 	unsigned int CtHi = Pt >> 32,

	xor	ecx, ecx
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 114  : 		List[i] = (int)speck64u96(

	lea	r9d, DWORD PTR [r11+999999]
; File C:\Users\user\Desktop\primitive-root\speck.h

; 22   : 	for(int i = 0; i < 26;)

	xor	eax, eax
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 114  : 		List[i] = (int)speck64u96(

	mov	r10d, 223344				; 00036870H
	mov	r8d, r11d
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	mov	edx, 100				; 00000064H
	npad	7
$LL12@main:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	ecx, 8
	add	ecx, edx
	ror	r10d, 8
	xor	ecx, r8d
	rol	edx, 3
	add	r10d, r8d
	ror	r9d, 8
	xor	edx, ecx
	rol	r8d, 3
	xor	r10d, eax
	ror	ecx, 8
	xor	r8d, r10d
	add	ecx, edx
	add	r9d, r8d
	rol	edx, 3
	xor	ecx, r8d
	inc	eax
	xor	r9d, eax
	rol	r8d, 3
	xor	r8d, r9d
	xor	edx, ecx
	inc	eax
	cmp	eax, 26
	jl	SHORT $LL12@main
; File C:\Users\user\Desktop\primitive-root\pf4.c

; 113  : 	for(int i = 0; i < Num; i++) {

	mov	DWORD PTR [rbx], edx
	inc	r11d
	add	rbx, 4
	cmp	r11d, 3000000				; 002dc6c0H
	jl	SHORT $LL9@main

; 121  : 		= malloc(VecLen * 3 * sizeof Vecs[0]);
; 122  : 	fill_list_rand(VecLen * 3, Vecs, 223344);
; 123  : 	for(int i = 0; i < 1000; i++) {

	lea	r8, QWORD PTR [rdi+4000000]
	mov	r10d, 1000				; 000003e8H
	npad	12
$LL4@main:

; 124  : 		vec_mod_pf4(VecLen, Vecs,

	lea	r9, QWORD PTR [rdi+8000000]
	mov	rdx, rdi
	call	vec_mod_pf4
	sub	r10, 1
	jne	SHORT $LL4@main

; 125  : 			(uint16_t *)(Vecs + VecLen),
; 126  : 			(uint16_t *)(Vecs + VecLen * 2));
; 127  : 	}
; 128  : 	return 0;
; 129  : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
main	ENDP
_TEXT	ENDS
END
