; Listing generated by Microsoft (R) Optimizing Compiler Version 19.28.29333.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_02EAMLCBHB@Eq@				; `string'
PUBLIC	??_C@_03NNEIEOJB@Neq@				; `string'
PUBLIC	??_C@_0BP@LGDPFEOC@?$CFs?3?70x?$CF?48x?0?50x?$CF?48x?5?$CIans?0?5res?$CJ?6@ ; `string'
PUBLIC	??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@		; `string'
PUBLIC	p3013_orders
PUBLIC	p3013_factors
EXTRN	__imp_malloc:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__security_check_cookie:PROC
p3013_orders DD	020001000H
	DD	015556000H
	DD	06000H
	ORG $+4
p3013_factors DD 02H
	DD	03H
	DD	0aaabH
CONST	ENDS
;	COMDAT ??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@
CONST	SEGMENT
??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@ DB 'Generator: %i', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@LGDPFEOC@?$CFs?3?70x?$CF?48x?0?50x?$CF?48x?5?$CIans?0?5res?$CJ?6@
CONST	SEGMENT
??_C@_0BP@LGDPFEOC@?$CFs?3?70x?$CF?48x?0?50x?$CF?48x?5?$CIans?0?5res?$CJ?6@ DB '%'
	DB	's:', 09H, '0x%.8x, 0x%.8x (ans, res)', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03NNEIEOJB@Neq@
CONST	SEGMENT
??_C@_03NNEIEOJB@Neq@ DB 'Neq', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EAMLCBHB@Eq@
CONST	SEGMENT
??_C@_02EAMLCBHB@Eq@ DB 'Eq', 00H			; `string'
CONST	ENDS
PUBLIC	main
PUBLIC	fill_list_rand
PUBLIC	search_p3013_gens
PUBLIC	is_p3013_gen
PUBLIC	pow_Zp_ring
PUBLIC	vec_modp3013
PUBLIC	test_modp3013
PUBLIC	mod_p3013_2
PUBLIC	mod_p3013
PUBLIC	speck64u96
PUBLIC	printf
PUBLIC	_vfprintf_l
PUBLIC	__local_stdio_printf_options
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN75
	DD	imagerel $LN75+616
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_list_rand DD imagerel $LN20
	DD	imagerel $LN20+141
	DD	imagerel $unwind$fill_list_rand
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$search_p3013_gens DD imagerel $LN34
	DD	imagerel $LN34+228
	DD	imagerel $unwind$search_p3013_gens
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$is_p3013_gen DD imagerel $LN23
	DD	imagerel $LN23+165
	DD	imagerel $unwind$is_p3013_gen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vec_modp3013 DD imagerel $LN23
	DD	imagerel $LN23+257
	DD	imagerel $unwind$vec_modp3013
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$test_modp3013 DD imagerel $LN34
	DD	imagerel $LN34+16
	DD	imagerel $unwind$test_modp3013
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$test_modp3013 DD imagerel $LN34+16
	DD	imagerel $LN34+396
	DD	imagerel $chain$1$test_modp3013
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$test_modp3013 DD imagerel $LN34+396
	DD	imagerel $LN34+404
	DD	imagerel $chain$2$test_modp3013
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN6
	DD	imagerel $LN6+85
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN4
	DD	imagerel $LN4+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b520fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 041b01H
	DD	07017521bH
	DD	030156016H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$test_modp3013 DD 021H
	DD	imagerel $LN34
	DD	imagerel $LN34+16
	DD	imagerel $unwind$test_modp3013
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$test_modp3013 DD 040d21H
	DD	07640dH
	DD	063405H
	DD	imagerel $LN34
	DD	imagerel $LN34+16
	DD	imagerel $unwind$test_modp3013
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$test_modp3013 DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vec_modp3013 DD 081401H
	DD	047414H
	DD	03640fH
	DD	02540aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$is_p3013_gen DD 040a01H
	DD	02740aH
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$search_p3013_gens DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_list_rand DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	0c1e01H
	DD	0b741eH
	DD	0a641eH
	DD	09541eH
	DD	08341eH
	DD	0f01a321eH
	DD	0c016e018H
xdata	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 87   :         static unsigned __int64 _OptionsStorage;
; 88   :         return &_OptionsStorage;

	lea	rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 89   :     }

	ret	0
__local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$dead$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 642  :     {

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, r9
	mov	rdi, rdx
	mov	rsi, rcx

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rbx
	mov	r8, rdi
	mov	rdx, rsi
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 644  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.18362.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Format$ = 80
printf	PROC						; COMDAT

; 954  :     {

$LN6:
	mov	QWORD PTR [rsp+8], rcx
	mov	QWORD PTR [rsp+16], rdx
	mov	QWORD PTR [rsp+24], r8
	mov	QWORD PTR [rsp+32], r9
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx

; 955  :         int _Result;
; 956  :         va_list _ArgList;
; 957  :         __crt_va_start(_ArgList, _Format);

	lea	rsi, QWORD PTR _Format$[rsp+8]

; 958  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

	mov	ecx, 1
	call	QWORD PTR __imp___acrt_iob_func
	mov	rbx, rax

; 643  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

	call	__local_stdio_printf_options
	xor	r9d, r9d
	mov	QWORD PTR [rsp+32], rsi
	mov	r8, rdi
	mov	rdx, rbx
	mov	rcx, QWORD PTR [rax]
	call	QWORD PTR __imp___stdio_common_vfprintf

; 959  :         __crt_va_end(_ArgList);
; 960  :         return _Result;
; 961  :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\speck.h
;	COMDAT speck64u96
_TEXT	SEGMENT
Pt$ = 8
KeyLo$ = 16
KeyHiLo$ = 24
KeyHiHi$ = 32
speck64u96 PROC						; COMDAT

; 11   : 	extern unsigned int _rotl(unsigned int, int);
; 12   : 	extern unsigned int _rotr(unsigned int, int);
; 13   : #define _SPECKXXR(x, y, k) \
; 14   : 	(y = _rotr(x ^ y, 3),  \
; 15   : 		x = _rotl(         \
; 16   : 			(unsigned long long)((x ^ (k)) - y), 8))
; 17   : #define _SPECKXX(Hi, Lo, k)          \
; 18   : 	(Hi = (_rotr(Hi, 8) + Lo) ^ (k), \
; 19   : 		Lo = _rotl(Lo, 3) ^ Hi)
; 20   : 	unsigned int CtHi = Pt >> 32,

	mov	rax, rcx
	shr	rax, 32					; 00000020H

; 21   : 				 CtLo = Pt & 0xffffffffu;
; 22   : 	for(int i = 0; i < 26;)

	xor	r10d, r10d
	npad	6
$LL2@speck64u96:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	eax, 8
	add	eax, ecx
	ror	r8d, 8
	xor	eax, edx
	rol	ecx, 3
	add	r8d, edx
	ror	r9d, 8
	xor	ecx, eax
	rol	edx, 3
	xor	r8d, r10d
	ror	eax, 8
	xor	edx, r8d
	add	eax, ecx
	add	r9d, edx
	rol	ecx, 3
	xor	eax, edx
	inc	r10d
	xor	r9d, r10d
	rol	edx, 3
	xor	edx, r9d
	xor	ecx, eax
	inc	r10d
	cmp	r10d, 26
	jl	SHORT $LL2@speck64u96

; 26   : 			_SPECKXX(KeyHiHi, KeyLo, i++));
; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	shl	rax, 32					; 00000020H
	or	rax, rcx

; 28   : #undef _SPECKXXR
; 29   : #undef _SPECKXX
; 30   : }

	ret	0
speck64u96 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\p3013.c
;	COMDAT mod_p3013
_TEXT	SEGMENT
v$ = 8
mod_p3013 PROC						; COMDAT

; 10   : 	const uint64_t f1 = v & (0x3ffull << 51);

	mov	rdx, rcx

; 11   : 	const uint64_t m1 = f1 + (f1 >> 17) + (f1 >> 30);
; 12   : 	const uint64_t vi1 = v - m1;

	mov	r8, rcx
	mov	rax, 2303591209400008704		; 1ff8000000000000H
	and	rdx, rax
	mov	rax, rdx
	shr	rax, 30
	sub	r8, rax
	mov	rax, rdx
	shr	rax, 17
	sub	r8, rax

; 13   : 	const uint64_t v1

	mov	rax, 1125908497825792			; 0004000200100000H
	sub	r8, rdx
	cmp	rcx, r8
	sbb	r9, r9
	and	r9, rax

; 14   : 		= vi1 + (vi1 > v ? (0x40002001ull << 20) : 0);
; 15   : 	const uint64_t f2 = v1 & (0x3ffull << 41);

	mov	rax, 2249600790429696			; 0007fe0000000000H
	add	r9, r8
	mov	rcx, r9

; 16   : 	const uint64_t m2 = f2 + (f2 >> 17) + (f2 >> 30);
; 17   : 	const uint64_t vi2 = v1 - m2;

	mov	rdx, r9
	and	rcx, rax
	mov	rax, rcx
	shr	rax, 30
	sub	rdx, rax
	mov	rax, rcx
	shr	rax, 17
	sub	rdx, rax

; 18   : 	const uint64_t v2

	mov	rax, 1099520017408			; 0000010000800400H
	sub	rdx, rcx
	cmp	r9, rdx
	sbb	r8, r8
	and	r8, rax

; 19   : 		= vi2 + (vi2 > v1 ? (0x40002001ull << 10) : 0);
; 20   : 	const uint64_t f3 = v2 & (0x7ffull << 30);

	mov	rax, 2197949513728			; 000001ffc0000000H
	add	r8, rdx
	mov	rcx, r8

; 21   : 	const uint64_t m3 = f3 + (f3 >> 17) + (f3 >> 30);
; 22   : 	const uint64_t vi3 = v2 - m3;

	mov	rdx, r8
	and	rcx, rax
	mov	rax, rcx
	shr	rax, 30
	sub	rdx, rax
	mov	rax, rcx
	shr	rax, 17
	sub	rdx, rax
	sub	rdx, rcx

; 23   : 	const uint64_t v3

	cmp	r8, rdx
	sbb	eax, eax
	and	eax, 1073750017				; 40002001H
	add	eax, edx

; 24   : 		= vi3 + (vi3 > v2 ? 0x40002001ull : 0);
; 25   : 	return (int32_t)(v3 & 0xffffffffull);
; 26   : }

	ret	0
mod_p3013 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\p3013.c
;	COMDAT mod_p3013_2
_TEXT	SEGMENT
v$ = 8
mod_p3013_2 PROC					; COMDAT

; 28   : 	const uint64_t c2 = 0x1ffffffffull/0x10001ull+1;
; 29   : 	const uint64_t c = UINT64_MAX / 0x40002001ull + 1;
; 30   : 	const uint64_t m = (c * v * 0x40002001ull) >> 32;

	imul	rax, rcx, 1073496050			; 3ffc3ff2H
	shr	rax, 32					; 00000020H

; 31   : 	return (int32_t)m;
; 32   : }

	ret	0
mod_p3013_2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\p3013.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\p3013.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\p3013.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\p3013.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\p3013.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\p3013.c
;	COMDAT test_modp3013
_TEXT	SEGMENT
Num$ = 48
Nonce$ = 56
test_modp3013 PROC					; COMDAT

; 33   : int test_modp3013(const int Num, const int Nonce) {

$LN34:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, ecx

; 34   : 	if(Num <= 0) return 0;

	test	ecx, ecx
	jle	$LN32@test_modp3
	mov	QWORD PTR [rsp+48], rbx
	lea	ebx, DWORD PTR [rdx+3]
	mov	QWORD PTR [rsp+56], rsi
	mov	rsi, 9223301660057661447		; 7fffbffe2001f007H
	npad	9
$LL17@test_modp3:

; 35   : 	const uint64_t a

	lea	eax, DWORD PTR [rbx-3]
	mov	r9d, 99					; 00000063H
	cdqe
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	lea	r8d, DWORD PTR [rbx-3]
	shr	rax, 32					; 00000020H
; File C:\Users\user\Desktop\primitive-root\p3013.c

; 35   : 	const uint64_t a

	lea	r10d, DWORD PTR [rbx+2]
; File C:\Users\user\Desktop\primitive-root\speck.h

; 22   : 	for(int i = 0; i < 26;)

	xor	r11d, r11d
; File C:\Users\user\Desktop\primitive-root\p3013.c

; 35   : 	const uint64_t a

	mov	ecx, ebx
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	mov	edx, r8d
	npad	1
$LL6@test_modp3:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	eax, 8
	add	eax, edx
	ror	r10d, 8
	xor	eax, ecx
	rol	edx, 3
	add	r10d, ecx
	ror	r9d, 8
	xor	edx, eax
	rol	ecx, 3
	xor	r10d, r11d
	ror	eax, 8
	xor	ecx, r10d
	add	eax, edx
	add	r9d, ecx
	rol	edx, 3
	xor	eax, ecx
	inc	r11d
	xor	r9d, r11d
	rol	ecx, 3
	xor	ecx, r9d
	xor	edx, eax
	inc	r11d
	cmp	r11d, 26
	jl	SHORT $LL6@test_modp3

; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	mov	r10d, eax
; File C:\Users\user\Desktop\primitive-root\p3013.c

; 38   : 	const uint64_t b

	mov	r9d, 111				; 0000006fH
; File C:\Users\user\Desktop\primitive-root\speck.h

; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	mov	eax, edx
	shl	r10, 32					; 00000020H
	or	r10, rax
; File C:\Users\user\Desktop\primitive-root\p3013.c

; 35   : 	const uint64_t a

	mov	rax, rsi
	mul	r10
	shr	rdx, 29
	imul	rax, rdx, 1073750017			; 40002001H

; 38   : 	const uint64_t b

	lea	edx, DWORD PTR [rbx+13]
	sub	r10, rax
	lea	eax, DWORD PTR [rbx-1]
	movsxd	rcx, eax
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	lea	eax, DWORD PTR [rbx-1]
	shr	rcx, 32					; 00000020H

; 22   : 	for(int i = 0; i < 26;)

	xor	r11d, r11d
	npad	3
$LL11@test_modp3:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	ecx, 8
	add	ecx, eax
	ror	r9d, 8
	xor	ecx, edx
	rol	eax, 3
	add	r9d, edx
	ror	r8d, 8
	xor	eax, ecx
	rol	edx, 3
	xor	r9d, r11d
	ror	ecx, 8
	xor	edx, r9d
	add	ecx, eax
	add	r8d, edx
	rol	eax, 3
	xor	ecx, edx
	inc	r11d
	xor	r8d, r11d
	rol	edx, 3
	xor	edx, r8d
	xor	eax, ecx
	inc	r11d
	cmp	r11d, 26
	jl	SHORT $LL11@test_modp3

; 27   : 	return ((((unsigned long long)CtHi) << 32) | CtLo);

	shl	rcx, 32					; 00000020H
	or	rcx, rax
; File C:\Users\user\Desktop\primitive-root\p3013.c

; 38   : 	const uint64_t b

	mov	rax, rsi
	mul	rcx
	shr	rdx, 29
	imul	rax, rdx, 1073750017			; 40002001H
	sub	rcx, rax

; 39   : 		= speck64u96(Nonce + 2, Nonce + 16, 111, Nonce)
; 40   : 		% 0x40002001;
; 41   : 	const int32_t ans = (a * b) % 0x40002001;

	mov	rax, rsi
	imul	rcx, r10
	mul	rcx
	shr	rdx, 29
	imul	rax, rdx, 1073750017			; 40002001H
	mov	rdx, rcx
	sub	rdx, rax

; 30   : 	const uint64_t m = (c * v * 0x40002001ull) >> 32;

	imul	rax, rcx, 1073496050			; 3ffc3ff2H
	shr	rax, 32					; 00000020H

; 42   : 	const int32_t res = mod_p3013_2(a * b);
; 43   : 	if(ans != res)

	cmp	edx, eax
	je	SHORT $LN3@test_modp3

; 44   : 		printf("%s:\t0x%.8x, 0x%.8x (ans, res)\n",

	mov	r8d, edx
	lea	rcx, OFFSET FLAT:??_C@_0BP@LGDPFEOC@?$CFs?3?70x?$CF?48x?0?50x?$CF?48x?5?$CIans?0?5res?$CJ?6@
	lea	rdx, OFFSET FLAT:??_C@_03NNEIEOJB@Neq@
	mov	r9d, eax
	call	printf
$LN3@test_modp3:

; 45   : 			(ans == res ? "Eq" : "Neq"), ans, res);
; 46   : 	return test_modp3013(Num - 1, Nonce + 100001);

	add	ebx, 100001				; 000186a1H
	dec	edi
	test	edi, edi
	jg	$LL17@test_modp3

; 34   : 	if(Num <= 0) return 0;

	mov	rsi, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+48]
$LN32@test_modp3:

; 47   : }

	xor	eax, eax
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
test_modp3013 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\p3013.c
;	COMDAT vec_modp3013
_TEXT	SEGMENT
Num$dead$ = 8
Iter$ = 16
vec_modp3013 PROC					; COMDAT

; 48   : void vec_modp3013(const int Num, int *restrict Iter) {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	mov	r10, rdx
	xor	r9d, r9d
	mov	rbx, 1125908497825792			; 0004000200100000H
	mov	r11, 2303591209400008704		; 1ff8000000000000H
	mov	rdi, 2249600790429696			; 0007fe0000000000H
	mov	rsi, 1099520017408			; 0000010000800400H
	mov	rbp, 2197949513728			; 000001ffc0000000H
	npad	4
$LL10@vec_modp30:

; 49   : 	for(int i = 0; i < Num; i++) {
; 50   : 		Iter[i] = mod_p3013(Iter[i]);

	movsxd	r8, DWORD PTR [r10+r9*4]

; 10   : 	const uint64_t f1 = v & (0x3ffull << 51);

	mov	rcx, r8

; 11   : 	const uint64_t m1 = f1 + (f1 >> 17) + (f1 >> 30);
; 12   : 	const uint64_t vi1 = v - m1;

	mov	rdx, r8
	and	rcx, r11
	mov	rax, rcx
	shr	rax, 30
	sub	rdx, rax
	mov	rax, rcx
	shr	rax, 17
	sub	rdx, rax
	sub	rdx, rcx

; 13   : 	const uint64_t v1

	cmp	r8, rdx
	sbb	r8, r8
	and	r8, rbx
	add	r8, rdx

; 14   : 		= vi1 + (vi1 > v ? (0x40002001ull << 20) : 0);
; 15   : 	const uint64_t f2 = v1 & (0x3ffull << 41);

	mov	rcx, r8

; 16   : 	const uint64_t m2 = f2 + (f2 >> 17) + (f2 >> 30);
; 17   : 	const uint64_t vi2 = v1 - m2;

	mov	rdx, r8
	and	rcx, rdi
	mov	rax, rcx
	shr	rax, 30
	sub	rdx, rax
	mov	rax, rcx
	shr	rax, 17
	sub	rdx, rax
	sub	rdx, rcx

; 18   : 	const uint64_t v2

	cmp	r8, rdx
	sbb	r8, r8
	and	r8, rsi
	add	r8, rdx

; 19   : 		= vi2 + (vi2 > v1 ? (0x40002001ull << 10) : 0);
; 20   : 	const uint64_t f3 = v2 & (0x7ffull << 30);

	mov	rcx, r8

; 21   : 	const uint64_t m3 = f3 + (f3 >> 17) + (f3 >> 30);
; 22   : 	const uint64_t vi3 = v2 - m3;

	mov	rdx, r8
	and	rcx, rbp
	mov	rax, rcx
	shr	rax, 30
	sub	rdx, rax
	mov	rax, rcx
	shr	rax, 17
	sub	rdx, rax
	sub	rdx, rcx

; 23   : 	const uint64_t v3

	cmp	r8, rdx
	sbb	eax, eax
	and	eax, 1073750017				; 40002001H
	add	eax, edx

; 49   : 	for(int i = 0; i < Num; i++) {
; 50   : 		Iter[i] = mod_p3013(Iter[i]);

	mov	DWORD PTR [r10+r9*4], eax
	inc	r9
	cmp	r9, 10000				; 00002710H
	jl	$LL10@vec_modp30

; 51   : 	}
; 52   : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rbp, QWORD PTR [rsp+16]
	mov	rsi, QWORD PTR [rsp+24]
	mov	rdi, QWORD PTR [rsp+32]
	ret	0
vec_modp3013 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\p3013.c
;	COMDAT pow_Zp_ring
_TEXT	SEGMENT
p$dead$ = 8
base$ = 16
exponent$ = 24
pow_Zp_ring PROC					; COMDAT

; 54   : 	const uint64_t base, const uint64_t exponent) {

	mov	r9, rdx

; 55   : 	uint64_t ans = 1;

	mov	r10d, 1

; 56   : 	for(uint64_t exp = exponent, g = base; exp;) {

	test	r8, r8
	je	SHORT $LN11@pow_Zp_rin
	mov	r11, 9223301660057661447		; 7fffbffe2001f007H
$LL2@pow_Zp_rin:

; 57   : 		if(exp & 1) { ans = (ans * g) % p; }

	test	r8b, 1
	je	SHORT $LN5@pow_Zp_rin
	imul	r10, r9
	mov	rax, r11
	mul	r10
	shr	rdx, 29
	imul	rax, rdx, 1073750017			; 40002001H
	sub	r10, rax
$LN5@pow_Zp_rin:

; 58   : 		exp = (exp >> 1);
; 59   : 		g = (g * g) % p;

	mov	rcx, r9
	mov	rax, r11
	imul	rcx, r9
	mul	rcx
	mov	r9, rcx
	shr	rdx, 29
	imul	rcx, rdx, 1073750017			; 40002001H
	sub	r9, rcx
	shr	r8, 1
	jne	SHORT $LL2@pow_Zp_rin
$LN11@pow_Zp_rin:

; 60   : 	}
; 61   : 	return ans;
; 62   : }

	mov	rax, r10
	ret	0
pow_Zp_ring ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\p3013.c
;	COMDAT is_p3013_gen
_TEXT	SEGMENT
a$ = 8
is_p3013_gen PROC					; COMDAT

; 63   : bool is_p3013_gen(const int32_t a) {

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rdi
	movsxd	r11, ecx
	lea	r10, OFFSET FLAT:p3013_orders
	mov	rbx, 9223301660057661447		; 7fffbffe2001f007H
	lea	rdi, OFFSET FLAT:p3013_orders+12
	npad	11
$LL4@is_p3013_g:

; 65   : 		const uint64_t r = pow_Zp_ring(

	movsxd	r8, DWORD PTR [r10]

; 55   : 	uint64_t ans = 1;

	mov	r9d, 1

; 56   : 	for(uint64_t exp = exponent, g = base; exp;) {

	mov	rcx, r11
	test	r8, r8
	je	SHORT $LN15@is_p3013_g
$LL8@is_p3013_g:

; 57   : 		if(exp & 1) { ans = (ans * g) % p; }

	test	r8b, 1
	je	SHORT $LN11@is_p3013_g
	imul	r9, rcx
	mov	rax, rbx
	mul	r9
	shr	rdx, 29
	imul	rax, rdx, 1073750017			; 40002001H
	sub	r9, rax
$LN11@is_p3013_g:

; 58   : 		exp = (exp >> 1);
; 59   : 		g = (g * g) % p;

	imul	rcx, rcx
	mov	rax, rbx
	mul	rcx
	shr	rdx, 29
	imul	rax, rdx, 1073750017			; 40002001H
	sub	rcx, rax
	shr	r8, 1
	jne	SHORT $LL8@is_p3013_g

; 66   : 			0x40002001, a, p3013_orders[i]);
; 67   : 		if(r <= 1) return false;

	cmp	r9, 1
	jbe	SHORT $LN15@is_p3013_g

; 64   : 	for(int i = 0; i < 3; i++) {

	add	r10, 4
	cmp	r10, rdi
	jl	SHORT $LL4@is_p3013_g

; 68   : 	}
; 69   : 	return true;

	mov	al, 1

; 70   : }

	mov	rbx, QWORD PTR [rsp+8]
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
$LN15@is_p3013_g:
	mov	rbx, QWORD PTR [rsp+8]
	xor	al, al
	mov	rdi, QWORD PTR [rsp+16]
	ret	0
is_p3013_gen ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\p3013.c
;	COMDAT search_p3013_gens
_TEXT	SEGMENT
Num$dead$ = 48
search_p3013_gens PROC					; COMDAT

; 71   : int search_p3013_gens(const int Num) {

$LN34:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 72   : 	for(int i = 0; i < Num; i++) {

	xor	edi, edi
	lea	r14, OFFSET FLAT:p3013_orders
	mov	ebx, edi
	lea	rbp, OFFSET FLAT:p3013_orders+12
	mov	rsi, 9223301660057661447		; 7fffbffe2001f007H
	npad	10
$LL4@search_p30:

; 64   : 	for(int i = 0; i < 3; i++) {

	mov	r10, r14
	npad	13
$LL10@search_p30:

; 65   : 		const uint64_t r = pow_Zp_ring(

	movsxd	r8, DWORD PTR [r10]

; 55   : 	uint64_t ans = 1;

	mov	r9d, 1

; 56   : 	for(uint64_t exp = exponent, g = base; exp;) {

	mov	rcx, rbx
	test	r8, r8
	je	SHORT $LN2@search_p30
$LL14@search_p30:

; 57   : 		if(exp & 1) { ans = (ans * g) % p; }

	test	r8b, 1
	je	SHORT $LN17@search_p30
	imul	r9, rcx
	mov	rax, rsi
	mul	r9
	shr	rdx, 29
	imul	rax, rdx, 1073750017			; 40002001H
	sub	r9, rax
$LN17@search_p30:

; 58   : 		exp = (exp >> 1);
; 59   : 		g = (g * g) % p;

	imul	rcx, rcx
	mov	rax, rsi
	mul	rcx
	shr	rdx, 29
	imul	rax, rdx, 1073750017			; 40002001H
	sub	rcx, rax
	shr	r8, 1
	jne	SHORT $LL14@search_p30

; 67   : 		if(r <= 1) return false;

	cmp	r9, 1
	jbe	SHORT $LN2@search_p30

; 60   : 	}
; 61   : 	return ans;
; 62   : }
; 63   : bool is_p3013_gen(const int32_t a) {
; 64   : 	for(int i = 0; i < 3; i++) {

	add	r10, 4
	cmp	r10, rbp
	jl	SHORT $LL10@search_p30

; 73   : 		if(is_p3013_gen(i)) {
; 74   : 			printf("Generator: %i\n", i);

	mov	edx, edi
	lea	rcx, OFFSET FLAT:??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@
	call	printf
$LN2@search_p30:

; 72   : 	for(int i = 0; i < Num; i++) {

	inc	edi
	inc	rbx
	cmp	edi, 10
	jl	$LL4@search_p30

; 75   : 		}
; 76   : 	}
; 77   : 	return 0;
; 78   : }

	mov	rbx, QWORD PTR [rsp+48]
	xor	eax, eax
	mov	rbp, QWORD PTR [rsp+56]
	mov	rsi, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
search_p3013_gens ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\p3013.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\p3013.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\p3013.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\p3013.c
;	COMDAT fill_list_rand
_TEXT	SEGMENT
Num$dead$ = 8
List$ = 16
fill_list_rand PROC					; COMDAT

; 80   : 	const int Num, int *restrict List) {

$LN20:
	mov	QWORD PTR [rsp+8], rbx
	mov	rbx, rdx

; 81   : 	for(int i = 0; i < Num; i++) {

	xor	r11d, r11d
	npad	5
$LL4@fill_list_:
; File C:\Users\user\Desktop\primitive-root\speck.h

; 20   : 	unsigned int CtHi = Pt >> 32,

	xor	eax, eax
; File C:\Users\user\Desktop\primitive-root\p3013.c

; 82   : 		List[i] = (int)speck64u96(100, 200, i, i + 2);

	lea	r9d, DWORD PTR [r11+2]
; File C:\Users\user\Desktop\primitive-root\speck.h

; 22   : 	for(int i = 0; i < 26;)

	xor	edx, edx
; File C:\Users\user\Desktop\primitive-root\p3013.c

; 82   : 		List[i] = (int)speck64u96(100, 200, i, i + 2);

	mov	r10d, r11d
	mov	r8d, 200				; 000000c8H
; File C:\Users\user\Desktop\primitive-root\speck.h

; 21   : 				 CtLo = Pt & 0xffffffffu;

	mov	ecx, 100				; 00000064H
	npad	10
$LL7@fill_list_:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	eax, 8
	add	eax, ecx
	ror	r10d, 8
	xor	eax, r8d
	rol	ecx, 3
	add	r10d, r8d
	ror	r9d, 8
	xor	ecx, eax
	rol	r8d, 3
	xor	r10d, edx
	ror	eax, 8
	xor	r8d, r10d
	add	eax, ecx
	add	r9d, r8d
	rol	ecx, 3
	xor	eax, r8d
	inc	edx
	xor	r9d, edx
	rol	r8d, 3
	xor	r8d, r9d
	xor	ecx, eax
	inc	edx
	cmp	edx, 26
	jl	SHORT $LL7@fill_list_
; File C:\Users\user\Desktop\primitive-root\p3013.c

; 81   : 	for(int i = 0; i < Num; i++) {

	mov	DWORD PTR [rbx], ecx
	inc	r11d
	add	rbx, 4
	cmp	r11d, 10000				; 00002710H
	jl	SHORT $LL4@fill_list_

; 83   : 	}
; 84   : }

	mov	rbx, QWORD PTR [rsp+8]
	ret	0
fill_list_rand ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\user\Desktop\primitive-root\p3013.c
; File C:\Users\user\Desktop\primitive-root\speck.h
; File C:\Users\user\Desktop\primitive-root\p3013.c
;	COMDAT main
_TEXT	SEGMENT
main	PROC						; COMDAT

; 85   : int main(void) {

$LN75:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rbp
	mov	QWORD PTR [rsp+24], rsi
	mov	QWORD PTR [rsp+32], rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 86   : 	const int Num = 10000;
; 87   : 	int *List = malloc(Num * sizeof List[0]);

	mov	ecx, 40000				; 00009c40H
	call	QWORD PTR __imp_malloc
	xor	edi, edi
	mov	rsi, rax
	mov	r11d, edi
	mov	rbx, rax
	npad	12
$LL6@main:

; 82   : 		List[i] = (int)speck64u96(100, 200, i, i + 2);

	lea	r9d, DWORD PTR [r11+2]
	mov	r10d, r11d
	mov	edx, 200				; 000000c8H
; File C:\Users\user\Desktop\primitive-root\speck.h

; 20   : 	unsigned int CtHi = Pt >> 32,

	mov	ecx, edi

; 21   : 				 CtLo = Pt & 0xffffffffu;

	mov	r8d, 100				; 00000064H

; 22   : 	for(int i = 0; i < 26;)

	mov	eax, edi
	npad	10
$LL9@main:

; 23   : 		(_SPECKXX(CtHi, CtLo, KeyLo),
; 24   : 			_SPECKXX(KeyHiLo, KeyLo, i++),
; 25   : 			_SPECKXX(CtHi, CtLo, KeyLo),

	ror	ecx, 8
	add	ecx, r8d
	ror	r10d, 8
	xor	ecx, edx
	rol	r8d, 3
	add	r10d, edx
	ror	r9d, 8
	xor	r8d, ecx
	rol	edx, 3
	xor	r10d, eax
	ror	ecx, 8
	xor	edx, r10d
	add	ecx, r8d
	add	r9d, edx
	rol	r8d, 3
	xor	ecx, edx
	inc	eax
	xor	r9d, eax
	rol	edx, 3
	xor	edx, r9d
	xor	r8d, ecx
	inc	eax
	cmp	eax, 26
	jl	SHORT $LL9@main
; File C:\Users\user\Desktop\primitive-root\p3013.c

; 81   : 	for(int i = 0; i < Num; i++) {

	mov	DWORD PTR [rbx], r8d
	inc	r11d
	add	rbx, 4
	cmp	r11d, 10000				; 00002710H
	jl	SHORT $LL6@main
	mov	r11, rdi
	mov	rbx, 2303591209400008704		; 1ff8000000000000H
	mov	rbp, 1125908497825792			; 0004000200100000H
	mov	r14, 2249600790429696			; 0007fe0000000000H
	mov	r15, 1099520017408			; 0000010000800400H
	mov	r12, 2197949513728			; 000001ffc0000000H
	npad	1
$LL51@main:

; 50   : 		Iter[i] = mod_p3013(Iter[i]);

	movsxd	r8, DWORD PTR [rsi+r11*4]

; 10   : 	const uint64_t f1 = v & (0x3ffull << 51);

	mov	rcx, r8

; 11   : 	const uint64_t m1 = f1 + (f1 >> 17) + (f1 >> 30);
; 12   : 	const uint64_t vi1 = v - m1;

	mov	rdx, r8
	and	rcx, rbx
	mov	rax, rcx
	shr	rax, 30
	sub	rdx, rax
	mov	rax, rcx
	shr	rax, 17
	sub	rdx, rax
	sub	rdx, rcx

; 13   : 	const uint64_t v1

	cmp	r8, rdx
	sbb	r8, r8
	and	r8, rbp
	add	r8, rdx

; 14   : 		= vi1 + (vi1 > v ? (0x40002001ull << 20) : 0);
; 15   : 	const uint64_t f2 = v1 & (0x3ffull << 41);

	mov	rcx, r8

; 16   : 	const uint64_t m2 = f2 + (f2 >> 17) + (f2 >> 30);
; 17   : 	const uint64_t vi2 = v1 - m2;

	mov	rdx, r8
	and	rcx, r14
	mov	rax, rcx
	shr	rax, 30
	sub	rdx, rax
	mov	rax, rcx
	shr	rax, 17
	sub	rdx, rax
	sub	rdx, rcx

; 18   : 	const uint64_t v2

	cmp	r8, rdx
	sbb	r10, r10
	and	r10, r15
	add	r10, rdx

; 19   : 		= vi2 + (vi2 > v1 ? (0x40002001ull << 10) : 0);
; 20   : 	const uint64_t f3 = v2 & (0x7ffull << 30);

	mov	r8, r10

; 21   : 	const uint64_t m3 = f3 + (f3 >> 17) + (f3 >> 30);
; 22   : 	const uint64_t vi3 = v2 - m3;

	mov	r9, r10
	and	r8, r12
	mov	rax, r8
	shr	rax, 30
	sub	r9, rax
	mov	rax, r8
	shr	rax, 17
	sub	r9, rax
	sub	r9, r8

; 23   : 	const uint64_t v3

	cmp	r10, r9
	sbb	eax, eax
	and	eax, 1073750017				; 40002001H
	add	eax, r9d

; 50   : 		Iter[i] = mod_p3013(Iter[i]);

	mov	DWORD PTR [rsi+r11*4], eax
	inc	r11
	cmp	r11, 10000				; 00002710H
	jl	$LL51@main

; 88   : 	fill_list_rand(Num, List);
; 89   : 	vec_modp3013(Num, List);
; 90   : 	test_modp3013(10000, 100);

	mov	edx, 100				; 00000064H
	mov	ecx, 10000				; 00002710H
	call	test_modp3013
	mov	rbx, rdi
	lea	r14, OFFSET FLAT:p3013_orders
	mov	rsi, 9223301660057661447		; 7fffbffe2001f007H
	lea	rbp, OFFSET FLAT:p3013_orders+12
	npad	9
$LL23@main:

; 64   : 	for(int i = 0; i < 3; i++) {

	mov	r10, r14
	npad	13
$LL29@main:

; 65   : 		const uint64_t r = pow_Zp_ring(

	movsxd	r9, DWORD PTR [r10]

; 55   : 	uint64_t ans = 1;

	mov	r8d, 1

; 56   : 	for(uint64_t exp = exponent, g = base; exp;) {

	mov	rcx, rbx
	test	r9, r9
	je	SHORT $LN21@main
$LL33@main:

; 57   : 		if(exp & 1) { ans = (ans * g) % p; }

	test	r9b, 1
	je	SHORT $LN36@main
	imul	r8, rcx
	mov	rax, rsi
	mul	r8
	shr	rdx, 29
	imul	rax, rdx, 1073750017			; 40002001H
	sub	r8, rax
$LN36@main:

; 58   : 		exp = (exp >> 1);
; 59   : 		g = (g * g) % p;

	imul	rcx, rcx
	mov	rax, rsi
	mul	rcx
	shr	rdx, 29
	imul	rax, rdx, 1073750017			; 40002001H
	sub	rcx, rax
	shr	r9, 1
	jne	SHORT $LL33@main

; 67   : 		if(r <= 1) return false;

	cmp	r8, 1
	jbe	SHORT $LN21@main

; 60   : 	}
; 61   : 	return ans;
; 62   : }
; 63   : bool is_p3013_gen(const int32_t a) {
; 64   : 	for(int i = 0; i < 3; i++) {

	add	r10, 4
	cmp	r10, rbp
	jl	SHORT $LL29@main

; 74   : 			printf("Generator: %i\n", i);

	mov	edx, edi
	lea	rcx, OFFSET FLAT:??_C@_0P@DMHBINJL@Generator?3?5?$CFi?6@
	call	printf
$LN21@main:

; 68   : 	}
; 69   : 	return true;
; 70   : }
; 71   : int search_p3013_gens(const int Num) {
; 72   : 	for(int i = 0; i < Num; i++) {

	inc	edi
	inc	rbx
	cmp	edi, 10
	jl	$LL23@main

; 91   : 	return search_p3013_gens(10);

	mov	rbx, QWORD PTR [rsp+64]
	xor	eax, eax

; 92   : }

	mov	rbp, QWORD PTR [rsp+72]
	mov	rsi, QWORD PTR [rsp+80]
	mov	rdi, QWORD PTR [rsp+88]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	r12
	ret	0
main	ENDP
_TEXT	ENDS
END
